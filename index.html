<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
  
  <title>HealthYoda - Your Health Assistant</title>
  <meta name="description" content="Ask HealthYoda for health-related queries and get instant, intelligent responses. Your AI-powered health assistant.">
  <meta name="keywords" content="AI Chat Agent, AI assistant, health chatbot, HealthYoda, health assistant">
  <meta name="author" content="HealthYoda">
  <meta name="google-site-verification" content="PhjlsaI1LwJ0elVNYMvimmGx_a_PXGb6XQZZSRWsm10" />
  <meta name="robots" content="noindex, follow">
  
  <!-- Open Graph -->
  <meta property="og:title" content="HealthYoda - Your Health Assistant">
  <meta property="og:description" content="Ask HealthYoda for health-related queries and get instant, intelligent responses. Your AI-powered health assistant.">
  <meta property="og:type" content="website">
  
  <!-- Twitter Cards -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="HealthYoda - Your Health Assistant">
  <meta name="twitter:description" content="Ask HealthYoda for health-related queries and get instant, intelligent responses. Your AI-powered health assistant.">
  
  <!-- Structured Data (Schema.org) -->
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "HealthYoda",
      "description": "HealthYoda offers instant, AI-driven health guidance. Get expert health insights and information.",
      "applicationCategory": "HealthApplication",
      "operatingSystem": "Web"
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <style>
    /* Loading animation */
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    html {
      scrollbar-gutter: stable;
    }

    body { 
      font-family: Arial, sans-serif; 
      background: white; 
      margin: 0; 
      padding: 0;
      min-height: 100vh;
      scroll-behavior: smooth;
      overflow-x: hidden; /* Prevent horizontal scroll */
      position: relative; /* Ensure proper stacking context */
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: white;
      width: 100%;
      padding: 10px 20px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      min-height: 60px; /* Ensure minimum height */
      box-sizing: border-box;
    }

    header img {
      height: 40px;
    }

    .header-controls {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .voice-toggle-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: #f8f9fa;
      color: #495057;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s ease;
      font-family: inherit;
      min-width: 100px;
    }

    .voice-toggle-btn:hover {
      background: #e9ecef;
      border-color: #adb5bd;
      color: #212529;
    }

    .voice-toggle-btn.active {
      background: #28a745;
      color: white;
      border-color: #28a745;
    }

    .voice-toggle-btn.active:hover {
      background: #218838;
      border-color: #1e7e34;
    }

    .new-chat-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: #f8f9fa;
      color: #495057;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s ease;
      font-family: inherit;
      min-width: 100px;
    }

    .new-chat-btn:hover {
      background: #e9ecef;
      border-color: #adb5bd;
      color: #212529;
    }

    .new-chat-btn:active {
      background: #dee2e6;
      transform: translateY(1px);
    }

    .new-chat-btn.undo-mode {
      background: #dc3545;
      color: white;
      border-color: #dc3545;
      min-width: 100px;
    }

    .new-chat-btn.undo-mode:hover {
      background: #c82333;
      border-color: #bd2130;
    }

    /* Settings button */
    .settings-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: #f8f9fa;
      color: #495057;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s ease;
      font-family: inherit;
      min-width: 100px;
    }

    .settings-btn:hover {
      background: #e9ecef;
      border-color: #adb5bd;
      color: #212529;
    }

    .settings-btn.active {
      background: #007bff;
      color: white;
      border-color: #007bff;
    }

    /* Settings panel */
    .settings-panel {
      position: fixed;
      top: 60px;
      right: 20px;
      width: 380px;
      max-height: calc(100vh - 80px);
      background: white;
      border: 1px solid #dee2e6;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      z-index: 999;
      display: none;
      overflow-y: auto;
    }

    .settings-panel.open {
      display: block;
      animation: slideIn 0.2s ease-out;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .settings-header {
      padding: 16px 20px;
      border-bottom: 1px solid #dee2e6;
      background: #f8f9fa;
      border-radius: 8px 8px 0 0;
    }

    .settings-header h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: #212529;
    }

    .settings-content {
      padding: 20px;
    }

    .settings-section {
      margin-bottom: 24px;
    }

    .settings-section:last-child {
      margin-bottom: 0;
    }

    .settings-section-title {
      font-size: 14px;
      font-weight: 600;
      color: #495057;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .settings-item {
      margin-bottom: 16px;
    }

    .settings-item:last-child {
      margin-bottom: 0;
    }

    .settings-label {
      display: block;
      font-size: 14px;
      font-weight: 500;
      color: #333;
      margin-bottom: 8px;
    }

    .settings-description {
      font-size: 12px;
      color: #666;
      margin-top: 4px;
    }

    /* Model selector dropdown */
    .model-selector {
      position: relative;
      display: inline-block;
    }

    .model-select-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      background: #f8f9fa;
      color: #495057;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s ease;
      font-family: inherit;
      min-width: 140px;
    }

    .model-select-btn:hover {
      background: #e9ecef;
      border-color: #adb5bd;
      color: #212529;
    }

    .model-dropdown-arrow {
      font-size: 12px;
      transition: transform 0.2s ease;
    }

    .model-selector.open .model-dropdown-arrow {
      transform: rotate(180deg);
    }

    .model-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      min-width: 100%;
      max-height: 250px;
      overflow-y: auto;
      overflow-x: hidden;
      z-index: 1050;
      display: none;
      margin-top: 4px;
    }

    .model-dropdown.show {
      display: block;
    }

    .model-option {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      cursor: pointer;
      border-bottom: 1px solid #f8f9fa;
      transition: background-color 0.2s ease;
    }

    .model-option:last-child {
      border-bottom: none;
    }

    .model-option:hover {
      background: #f8f9fa;
    }

    .model-option.active {
      background: #e3f2fd;
      color: #1976d2;
      font-weight: 500;
    }

    .model-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .model-name {
      font-size: 14px;
      font-weight: 500;
    }

    .model-provider {
      font-size: 12px;
      color: #6c757d;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .model-status {
      font-size: 12px;
      color: #28a745;
      font-weight: 500;
    }

    /* Toast notifications */
    .toast-notification {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      min-width: 300px;
      max-width: 500px;
      padding: 0;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      animation: toastSlideIn 0.3s ease-out;
    }

    .toast-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: white;
      border-radius: 8px;
      border-left: 4px solid #007bff;
    }

    .toast-success .toast-content {
      border-left-color: #28a745;
    }

    .toast-error .toast-content {
      border-left-color: #dc3545;
    }

    .toast-warning .toast-content {
      border-left-color: #ffc107;
    }

    .toast-info .toast-content {
      border-left-color: #17a2b8;
    }

    .toast-message {
      flex: 1;
      font-size: 14px;
      color: #333;
    }

    .toast-close {
      background: none;
      border: none;
      font-size: 20px;
      color: #999;
      cursor: pointer;
      padding: 0;
      margin-left: 12px;
      line-height: 1;
    }

    .toast-close:hover {
      color: #666;
    }

    @keyframes toastSlideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .countdown-container {
      position: relative;
      margin-left: 4px;
      width: 24px;
      height: 20px;
    }

    .countdown-circle {
      width: 24px;
      height: 24px;
      position: absolute;
      top: -2px;
      left: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .countdown-circle svg {
      width: 24px;
      height: 24px;
      transform: rotate(-90deg);
      position: absolute;
      top: 0;
      left: 0;
    }

    .countdown-circle .progress-ring {
      fill: none;
      stroke-width: 2;
    }

    .countdown-circle .progress-ring-bg {
      stroke: rgba(255, 255, 255, 0.4);
    }

    .countdown-circle .progress-ring-fill {
      stroke: #fff;
      stroke-linecap: round;
      transition: stroke-dasharray 0.1s linear;
    }

    .countdown-text {
      font-size: 11px;
      font-weight: bold;
      color: white;
      position: absolute;
      z-index: 2;
      text-align: center;
      line-height: 1;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .user-menu {
      position: relative;
      display: flex;
      align-items: center;
      cursor: pointer;
      padding: 8px 12px;
      border-radius: 20px;
      transition: background-color 0.3s ease;
    }

    .user-menu:hover {
      background-color: #f5f5f5;
    }

    .user-info {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .user-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background-color: #0129ac;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 14px;
    }

    .user-name {
      font-size: 14px;
      font-weight: 500;
      color: #333;
    }

    .dropdown-arrow {
      width: 0;
      height: 0;
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-top: 4px solid #666;
      margin-left: 4px;
    }

    .user-dropdown {
      position: absolute;
      top: 100%;
      right: 20px;
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      min-width: 200px;
      z-index: 1001;
      display: none;
      margin-top: 5px;
    }

    .user-dropdown.show {
      display: block;
    }

    .dropdown-item {
      padding: 12px 16px;
      cursor: pointer;
      border-bottom: 1px solid #f0f0f0;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: background-color 0.2s ease;
    }

    .dropdown-item:last-child {
      border-bottom: none;
    }

    .dropdown-item:hover {
      background-color: #f5f5f5;
    }

    .dropdown-item.logout {
      color: #d32f2f;
    }

    .dropdown-item.logout:hover {
      background-color: #ffebee;
    }

    .main-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 80px; /* Space for fixed header */
      min-height: calc(100vh - 80px); /* Ensure content takes full height */
    }

    #messages {
      width: 60%;
      padding: 20px 10px 20px 10px;
      margin-bottom: 50px; /* Space for fixed footer */
      display: flex;
      flex-direction: column;
    }

    .message { 
      margin: 8px 0; 
      padding: 10px 15px; 
      border-radius: 20px; 
      width: fit-content; 
      max-width: 70%;
      word-wrap: break-word;
    }

    .user { 
      background: #e1ecff; 
      color: black; 
      margin-left: auto; 
      text-align: left;
    }
    
    .user-message-wrapper {
      display: inline-flex;
      flex-direction: column;
      align-items: flex-end;
      margin: 8px 0;
      margin-left: auto;
      max-width: 70%;
    }
    
    .user-message-wrapper.editing {
      max-width: 70%;
    }
    
    .user-message-wrapper .message.user {
      margin: 0;
      width: auto;
      max-width: none;
    }

    .bot { 
      background: white; 
      color: black; 
      margin-right: auto; 
      text-align: left; 
      position: relative;
      padding-bottom: 35px; /* Extra space for feedback buttons */
    }

    /* Thinking animation */
    .thinking {
      display: flex;
      align-items: center;
      gap: 8px;
      font-style: italic;
      color: #666;
    }

    .thinking-dots {
      display: inline-flex;
      gap: 4px;
    }

    .thinking-dots span {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background-color: #666;
      animation: thinking-bounce 1.4s infinite ease-in-out both;
    }

    .thinking-dots span:nth-child(1) {
      animation-delay: -0.32s;
    }

    .thinking-dots span:nth-child(2) {
      animation-delay: -0.16s;
    }

    .thinking-dots span:nth-child(3) {
      animation-delay: 0s;
    }

    @keyframes thinking-bounce {
      0%, 80%, 100% {
        transform: scale(0);
        opacity: 0.5;
      }
      40% {
        transform: scale(1);
        opacity: 1;
      }
    }

    /* Markdown styling for bot messages */
    .bot h1, .bot h2, .bot h3, .bot h4, .bot h5, .bot h6 {
      margin: 10px 0 5px 0;
      font-weight: bold;
    }
    
    .bot h1 { font-size: 1.5em; }
    .bot h2 { font-size: 1.3em; }
    .bot h3 { font-size: 1.1em; }
    
    .bot ul, .bot ol {
      margin: 10px 0;
      padding-left: 20px;
    }
    
    .bot li {
      margin: 5px 0;
    }
    
    .bot strong {
      font-weight: bold;
    }
    
    .bot em {
      font-style: italic;
    }
    
    .bot code {
      background-color: #f4f4f4;
      padding: 2px 4px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
    }
    
    .bot pre {
      background-color: #f4f4f4;
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto;
      margin: 10px 0;
    }
    
    .bot pre code {
      background: none;
      padding: 0;
    }
    
    .bot blockquote {
      border-left: 4px solid #ddd;
      margin: 10px 0;
      padding-left: 15px;
      color: #666;
    }
    
    .bot a {
      color: #0066cc;
      text-decoration: underline;
    }
    
    .bot a:hover {
      color: #004499;
    }

    /* Copy button styles - ChatGPT style */
    .copy-button {
      background: transparent;
      border: none;
      border-radius: 4px;
      padding: 4px 6px;
      cursor: pointer;
      font-size: 16px;
      color: #6e6e80;
      transition: all 0.15s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      line-height: 1;
    }

    .copy-button:hover {
      background: #f4f4f4;
      color: #1a1a1a;
    }

    .copy-button.copied {
      background: #f4f4f4;
      color: #10a37f;
    }

    .message.bot {
      position: relative;
    }

    .message.bot .message-content {
      margin-bottom: 0;
    }

    /* Feedback buttons - ChatGPT style */
    .feedback-buttons {
      display: flex;
      gap: 4px;
      margin-top: -6px;
      align-items: center;
    }

    .feedback-btn {
      background: transparent;
      border: none;
      border-radius: 4px;
      padding: 4px 6px;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.15s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: #6e6e80;
      width: 28px;
      height: 28px;
      line-height: 1;
    }

    .feedback-btn:hover {
      background: #f4f4f4;
      color: #1a1a1a;
    }

    .feedback-btn.selected {
      background: #f4f4f4;
      color: #1a1a1a;
    }

    .feedback-btn.thumbs-up.selected {
      color: #10a37f;
    }

    .feedback-btn.thumbs-down.selected {
      color: #ef4444;
    }

    /* Emoji button styling - emojis don't need filters */

    .feedback-text {
      font-size: 11px;
      color: #6c757d;
      margin-left: 4px;
    }

    /* Edit button for user messages - matching feedback button style */
    .edit-button-container {
      display: flex;
      gap: 4px;
      margin-top: 4px;
      margin-right: 8px;
      align-items: center;
      justify-content: flex-end;
    }

    .edit-btn {
      background: transparent;
      border: none;
      border-radius: 4px;
      padding: 4px 6px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.15s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: #6e6e80;
      width: 28px;
      height: 28px;
    }

    .edit-btn:hover {
      background: #f4f4f4;
      color: #1a1a1a;
    }

    .edit-btn svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
    }
    
    /* Make edit button SVG match the filtered icon style */
    .edit-btn svg {
      opacity: 0.7;
    }
    
    .edit-btn:hover svg {
      opacity: 1;
    }

    /* Edit mode styles - inline editing */
    .user-message-wrapper.editing .message.user {
      padding: 0;
      border: 2px solid #0129ac;
      box-shadow: 0 0 0 1px rgba(1, 41, 172, 0.1);
    }

    .edit-textarea {
      width: 100%;
      min-height: 40px;
      padding: 10px 15px;
      border: none;
      border-radius: 20px;
      font-family: inherit;
      font-size: 16px;
      resize: none;
      box-sizing: border-box;
      line-height: 1.5;
      background: transparent;
      color: black;
      overflow: hidden;
    }

    .edit-textarea:focus {
      outline: none;
    }

    .edit-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 8px;
    }

    .edit-action-btn {
      padding: 6px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    .edit-save-btn {
      background: #0129ac;
      color: white;
    }

    .edit-save-btn:hover {
      background: #0056b3;
    }

    .edit-cancel-btn {
      background: #e9ecef;
      color: #495057;
    }

    .edit-cancel-btn:hover {
      background: #dee2e6;
    }

    /* Scroll to bottom button */
    #scroll-to-bottom-btn {
      position: fixed;
      bottom: 100px;
      right: 40px;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: #0129ac;
      color: white;
      border: none;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(1, 41, 172, 0.3);
      transition: all 0.3s ease;
      z-index: 999;
    }

    #scroll-to-bottom-btn:hover {
      background: #0056b3;
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(1, 41, 172, 0.4);
    }

    #scroll-to-bottom-btn:active {
      transform: translateY(0);
    }

    #scroll-to-bottom-btn.show {
      display: flex;
    }

    #scroll-to-bottom-btn svg {
      width: 24px;
      height: 24px;
      fill: currentColor;
    }

    #input-container {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: linear-gradient(to bottom, 
        rgba(255, 255, 255, 0) 0%, 
        rgba(255, 255, 255, 0.3) 10%, 
        rgba(255, 255, 255, 0.7) 40%, 
        rgba(255, 255, 255, 0.9) 70%, 
        rgba(255, 255, 255, 0.95) 100%);
      z-index: 1000;
      min-height: 80px; /* Ensure minimum height */
      box-sizing: border-box;
    }

    .input-wrapper {
      width: 60%;
      max-width: 800px;
      display: flex;
      align-items: center;
      position: relative;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      border-radius: 25px;
      padding: 8px;
      box-shadow: 
        0 8px 25px rgba(0, 0, 0, 0.1),
        0 4px 12px rgba(0, 0, 0, 0.08),
        0 2px 6px rgba(0, 0, 0, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    #user-input {
      flex: 1;
      padding: 8px 50px 8px 15px;
      border-radius: 20px;
      border: none;
      outline: none;
      font-size: 16px;
      box-sizing: border-box;
      background: transparent;
      transition: all 0.2s ease;
    }

    #user-input:focus {
      background: rgba(255, 255, 255, 0.1);
    }

    #user-input::placeholder {
      color: rgba(0, 0, 0, 0.6);
    }

    #send-btn {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      padding: 10px 15px;
      border: none;
      border-radius: 50px;
      background: #0129ac;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 
        0 4px 12px rgba(1, 41, 172, 0.3),
        0 2px 6px rgba(1, 41, 172, 0.2);
      transition: all 0.2s ease;
    }

    #send-btn svg {
      width: 20px;
      height: 20px;
      fill: currentColor;
      stroke: currentColor;
    }

    #send-btn:hover {
      background: #0056b3;
      box-shadow: 
        0 6px 16px rgba(1, 41, 172, 0.4),
        0 3px 8px rgba(1, 41, 172, 0.3);
      transform: translateY(-50%) translateY(-0.5px);
    }

    #send-btn:active {
      transform: translateY(-50%) translateY(0.5px);
      box-shadow: 
        0 2px 8px rgba(1, 41, 172, 0.3),
        0 1px 4px rgba(1, 41, 172, 0.2);
    }

    /* Voice controls */
    .mic-btn {
      position: absolute;
      right: 60px;
      top: 50%;
      transform: translateY(-50%);
      padding: 10px;
      border: none;
      border-radius: 50%;
      background: #6c757d;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.2s ease;
      width: 40px;
      height: 40px;
      z-index: 10;
      margin: 0;
      box-sizing: border-box;
    }

    .mic-btn:hover {
      background: #5a6268;
    }

    .mic-btn.recording {
      background: #dc3545;
      animation: pulse 1.5s ease-in-out infinite;
      /* Ensure position stays fixed during recording */
      position: absolute;
      right: 60px;
      top: 50%;
      transform: translateY(-50%);
    }

    .mic-btn.disabled {
      background: #e9ecef;
      color: #6c757d;
      cursor: not-allowed;
      opacity: 0.5;
    }

    .mic-btn svg {
      width: 20px;
      height: 20px;
      fill: currentColor;
    }

    @keyframes pulse {
      0%, 100% {
        box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7);
      }
      50% {
        box-shadow: 0 0 0 10px rgba(220, 53, 69, 0);
      }
    }

    .voice-status {
      position: absolute;
      top: -35px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      white-space: nowrap;
      display: none;
      z-index: 1001;
    }

    .voice-status.show {
      display: block;
    }

    .voice-status.recording {
      background: #dc3545;
    }

    .voice-status.transcribing {
      background: #ffc107;
      color: #000;
    }

    .voice-status.speaking {
      background: #28a745;
    }

    /* Hands-free confirmation modal */
    .modal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
    }

    .modal.show {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-content {
      background-color: white;
      padding: 30px;
      border-radius: 12px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      text-align: center;
      pointer-events: auto;
      position: relative;
      z-index: 1;
    }

    .modal-content h3 {
      margin: 0 0 15px 0;
      color: #0129ac;
      font-size: 20px;
    }

    .modal-content p {
      margin: 0 0 25px 0;
      color: #666;
      line-height: 1.6;
      font-size: 15px;
    }

    #countdownNumber {
      display: inline-block;
      font-size: 48px;
      font-weight: bold;
      color: #0129ac;
      margin: 0 8px;
      min-width: 50px;
      animation: countdownPulse 1s ease-in-out infinite;
    }

    @keyframes countdownPulse {
      0%, 100% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.1);
      }
    }

    .modal-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .modal-btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      flex: 1;
      max-width: 150px;
      pointer-events: auto;
      position: relative;
      z-index: 1;
    }

    .modal-btn.primary {
      background: #0129ac;
      color: white;
    }

    .modal-btn.primary:hover {
      background: #0056b3;
    }

    .modal-btn.secondary {
      background: #f8f9fa;
      color: #495057;
      border: 1px solid #dee2e6;
    }

    .modal-btn.secondary:hover {
      background: #e9ecef;
    }

    @media (max-width: 768px) {
      .modal-content {
        padding: 24px 20px;
        max-width: 90%;
      }

      .modal-content h3 {
        font-size: 18px;
      }

      .modal-content p {
        font-size: 14px;
      }

      .modal-buttons {
        flex-direction: column;
      }

      .modal-btn {
        max-width: 100%;
      }
    }

    /* ============================================
       MOBILE RESPONSIVE STYLES
       Keep sizes same, use space better
       ============================================ */
    
    @media (max-width: 768px) {
      /* Ensure body doesn't scroll horizontally */
      body {
        overflow-x: hidden !important;
      }
      
      /* Header adjustments for mobile - always at top */
      header {
        padding: 12px 16px;
        flex-wrap: wrap;
        gap: 8px;
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        width: 100% !important;
        min-height: 60px;
        box-sizing: border-box;
        -webkit-transform: translateZ(0); /* Force GPU acceleration for smooth scrolling */
        transform: translateZ(0);
      }

      header h1 {
        font-size: 22px !important;
        flex: 1;
        min-width: 0;
      }

      .header-controls {
        gap: 8px;
        flex-wrap: wrap;
      }

      /* Larger buttons on mobile - use available space */
      .voice-toggle-btn,
      .new-chat-btn {
        padding: 12px 18px !important;
        font-size: 15px !important;
        min-width: auto;
        flex: 1;
        min-width: 100px;
      }

      .voice-toggle-btn svg,
      .new-chat-btn svg {
        width: 22px !important;
        height: 22px !important;
      }

      /* User menu adjustments */
      .user-menu {
        flex-shrink: 0;
      }

      .user-avatar {
        width: 36px !important;
        height: 36px !important;
        font-size: 16px !important;
      }

      .user-name {
        font-size: 14px !important;
      }

      /* Main content - minimal padding on mobile */
      .main-content {
        padding: 70px 0px 90px 0px !important; /* Reduced top/bottom padding */
        align-items: stretch !important; /* Allow messages to stretch to edges */
      }

      /* Messages container */
      #messages {
        width: 100% !important;
      }

      /* Chat messages - remove horizontal margins, keep only vertical */
      .message {
        padding: 14px 18px !important;
        margin: 10px 0px !important; /* Remove left/right margin */
        max-width: 85% !important;
        font-size: 16px !important;
        line-height: 1.5 !important;
      }

      /* User message wrapper - align to right edge */
      .user-message-wrapper {
        max-width: 85% !important;
        margin: 10px 0px 10px auto !important; /* Remove left/right margin */
      }
      
      /* Bot messages stay on left by default (margin-right: auto is implicit) */

      .user-message-wrapper.editing {
        max-width: 85% !important;
      }

      /* Bot message content - better spacing */
      .bot {
        padding: 14px 18px 50px 18px !important;
      }

      .message-content {
        font-size: 16px !important;
        line-height: 1.6 !important;
      }

      /* Larger feedback buttons on mobile */
      .feedback-buttons {
        gap: 8px !important;
        margin-top: 8px !important;
      }

      .copy-button,
      .feedback-btn {
        width: 40px !important;
        height: 40px !important;
        font-size: 20px !important;
        padding: 8px !important;
      }

      .edit-button-container {
        gap: 8px !important;
        margin-top: 8px !important;
      }

      .edit-btn {
        width: 36px !important;
        height: 36px !important;
        font-size: 16px !important;
      }

      /* Input container - always at bottom */
      #input-container {
        padding: 12px 8px !important; /* Small horizontal padding to show rounded corners */
        bottom: 0 !important;
        left: 0 !important;
        right: 0 !important;
        width: 100% !important;
        position: fixed !important;
        min-height: 80px;
        box-sizing: border-box;
        -webkit-transform: translateZ(0); /* Force GPU acceleration */
        transform: translateZ(0);
      }

      .input-wrapper {
        padding: 12px 16px !important;
        border-radius: 24px !important; /* Keep rounded corners */
        margin: 0 !important;
        width: 100% !important; /* Full width on mobile */
        max-width: none !important; /* Remove max-width constraint */
        box-sizing: border-box !important;
      }

      #user-input {
        padding: 12px 120px 12px 16px !important;
        font-size: 17px !important;
        line-height: 1.5 !important;
      }

      /* Larger send and mic buttons */
      #send-btn {
        right: 10px !important;
        padding: 12px 16px !important;
        width: 48px !important;
        height: 48px !important;
      }

      #send-btn svg {
        width: 24px !important;
        height: 24px !important;
      }

      .mic-btn {
        right: 65px !important;
        width: 48px !important;
        height: 48px !important;
        padding: 12px !important;
        position: absolute !important;
        top: 50% !important;
        transform: translateY(-50%) !important;
      }
      
      .mic-btn.recording {
        position: absolute !important;
        right: 65px !important;
        top: 50% !important;
        transform: translateY(-50%) !important;
      }

      .mic-btn svg {
        width: 24px !important;
        height: 24px !important;
      }

      /* Voice status - larger text */
      .voice-status {
        font-size: 14px !important;
        padding: 8px 14px !important;
        top: -40px !important;
      }

      /* Scroll to bottom button - larger */
      #scroll-to-bottom-btn {
        width: 48px !important;
        height: 48px !important;
        padding: 12px !important;
        right: 16px !important;
        bottom: 80px !important;
      }

      #scroll-to-bottom-btn svg {
        width: 24px !important;
        height: 24px !important;
      }

      /* Markdown content - better readability */
      .bot h1 {
        font-size: 1.6em !important;
        margin: 12px 0 8px 0 !important;
      }

      .bot h2 {
        font-size: 1.4em !important;
        margin: 12px 0 8px 0 !important;
      }

      .bot h3 {
        font-size: 1.2em !important;
        margin: 10px 0 6px 0 !important;
      }

      .bot ul,
      .bot ol {
        margin: 12px 0 !important;
        padding-left: 24px !important;
      }

      .bot li {
        margin: 8px 0 !important;
        line-height: 1.6 !important;
      }

      .bot code {
        font-size: 0.95em !important;
        padding: 3px 6px !important;
      }

      .bot pre {
        padding: 12px !important;
        margin: 12px 0 !important;
      }

      .bot blockquote {
        margin: 12px 0 !important;
        padding-left: 18px !important;
      }

      /* Thinking animation - larger */
      .thinking {
        font-size: 16px !important;
        gap: 10px !important;
      }

      .thinking-dots span {
        width: 8px !important;
        height: 8px !important;
      }

      /* User dropdown - full width on mobile */
      .user-dropdown {
        right: 0 !important;
        left: auto !important;
        min-width: 200px !important;
      }

      .dropdown-item {
        padding: 12px 16px !important;
        font-size: 15px !important;
      }
    }

    /* Extra small devices (phones in portrait) */
    @media (max-width: 480px) {
      header {
        padding: 10px 12px !important;
      }

      header h1 {
        font-size: 20px !important;
      }

      .voice-toggle-btn,
      .new-chat-btn {
        padding: 10px 14px !important;
        font-size: 14px !important;
      }

      .main-content {
        padding: 75px 0px 95px 0px !important;
        align-items: stretch !important;
      }

      #messages {
        width: 100% !important;
      }

      .message {
        padding: 12px 16px !important;
        margin: 10px 0px !important;
        max-width: 90% !important;
      }

      .user-message-wrapper {
        max-width: 90% !important;
        margin: 10px 0px 10px auto !important;
      }

      #input-container {
        padding: 10px 6px !important;
        left: 0 !important;
        right: 0 !important;
        width: 100% !important;
      }

      .input-wrapper {
        padding: 10px 14px !important;
        border-radius: 20px !important;
        margin: 0 !important;
        width: 100% !important;
        max-width: none !important;
        box-sizing: border-box !important;
      }

      #user-input {
        padding: 10px 110px 10px 14px !important;
        font-size: 16px !important;
      }

      #send-btn,
      .mic-btn {
        width: 44px !important;
        height: 44px !important;
        right: 60px !important;
        position: absolute !important;
        top: 50% !important;
        transform: translateY(-50%) !important;
      }
      
      .mic-btn.recording {
        position: absolute !important;
        right: 60px !important;
        top: 50% !important;
        transform: translateY(-50%) !important;
      }
    }

    /* Evaluation Toggle Switch */
    .evaluation-toggle {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      background: #f5f5f5;
      border-radius: 8px;
      margin: 10px 0;
    }

    .evaluation-toggle label {
      font-weight: 600;
      color: #333;
      font-size: 14px;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 24px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .toggle-slider {
      background-color: #4CAF50;
    }

    input:checked + .toggle-slider:before {
      transform: translateX(26px);
    }

    #evaluationStatus {
      color: #666;
      font-size: 14px;
    }

    #evaluationLatency {
      color: #999;
      font-size: 12px;
      margin-left: 10px;
    }
  </style>
  <!-- Favicon removed - add your own icon if needed -->
</head>
<body>

  
  <header>
    <h1 style="margin: 0; font-size: 24px; color: #0129ac;">HealthYoda</h1>
    <div class="header-controls">
      <button class="new-chat-btn" id="newChatBtn">
        <span>
          <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg" class="icon" aria-hidden="true">
            <path d="M2.6687 11.333V8.66699C2.6687 7.74455 2.66841 7.01205 2.71655 6.42285C2.76533 5.82612 2.86699 5.31731 3.10425 4.85156L3.25854 4.57617C3.64272 3.94975 4.19392 3.43995 4.85229 3.10449L5.02905 3.02149C5.44666 2.84233 5.90133 2.75849 6.42358 2.71582C7.01272 2.66769 7.74445 2.66797 8.66675 2.66797H9.16675C9.53393 2.66797 9.83165 2.96586 9.83179 3.33301C9.83179 3.70028 9.53402 3.99805 9.16675 3.99805H8.66675C7.7226 3.99805 7.05438 3.99834 6.53198 4.04102C6.14611 4.07254 5.87277 4.12568 5.65601 4.20313L5.45581 4.28906C5.01645 4.51293 4.64872 4.85345 4.39233 5.27149L4.28979 5.45508C4.16388 5.7022 4.08381 6.01663 4.04175 6.53125C3.99906 7.05373 3.99878 7.7226 3.99878 8.66699V11.333C3.99878 12.2774 3.99906 12.9463 4.04175 13.4688C4.08381 13.9833 4.16389 14.2978 4.28979 14.5449L4.39233 14.7285C4.64871 15.1465 5.01648 15.4871 5.45581 15.7109L5.65601 15.7969C5.87276 15.8743 6.14614 15.9265 6.53198 15.958C7.05439 16.0007 7.72256 16.002 8.66675 16.002H11.3337C12.2779 16.002 12.9461 16.0007 13.4685 15.958C13.9829 15.916 14.2976 15.8367 14.5447 15.7109L14.7292 15.6074C15.147 15.3511 15.4879 14.9841 15.7117 14.5449L15.7976 14.3447C15.8751 14.128 15.9272 13.8546 15.9587 13.4688C16.0014 12.9463 16.0017 12.2774 16.0017 11.333V10.833C16.0018 10.466 16.2997 10.1681 16.6667 10.168C17.0339 10.168 17.3316 10.4659 17.3318 10.833V11.333C17.3318 12.2555 17.3331 12.9879 17.2849 13.5771C17.2422 14.0993 17.1584 14.5541 16.9792 14.9717L16.8962 15.1484C16.5609 15.8066 16.0507 16.3571 15.4246 16.7412L15.1492 16.8955C14.6833 17.1329 14.1739 17.2354 13.5769 17.2842C12.9878 17.3323 12.256 17.332 11.3337 17.332H8.66675C7.74446 17.332 7.01271 17.3323 6.42358 17.2842C5.90135 17.2415 5.44665 17.1577 5.02905 16.9785L4.85229 16.8955C4.19396 16.5601 3.64271 16.0502 3.25854 15.4238L3.10425 15.1484C2.86697 14.6827 2.76534 14.1739 2.71655 13.5771C2.66841 12.9879 2.6687 12.2555 2.6687 11.333ZM13.4646 3.11328C14.4201 2.334 15.8288 2.38969 16.7195 3.28027L16.8865 3.46485C17.6141 4.35685 17.6143 5.64423 16.8865 6.53613L16.7195 6.7207L11.6726 11.7686C11.1373 12.3039 10.4624 12.6746 9.72827 12.8408L9.41089 12.8994L7.59351 13.1582C7.38637 13.1877 7.17701 13.1187 7.02905 12.9707C6.88112 12.8227 6.81199 12.6134 6.84155 12.4063L7.10132 10.5898L7.15991 10.2715C7.3262 9.53749 7.69692 8.86241 8.23218 8.32715L13.2791 3.28027L13.4646 3.11328ZM15.7791 4.2207C15.3753 3.81702 14.7366 3.79124 14.3035 4.14453L14.2195 4.2207L9.17261 9.26856C8.81541 9.62578 8.56774 10.0756 8.45679 10.5654L8.41772 10.7773L8.28296 11.7158L9.22241 11.582L9.43433 11.543C9.92426 11.432 10.3749 11.1844 10.7322 10.8271L15.7791 5.78027L15.8552 5.69629C16.185 5.29194 16.1852 4.708 15.8552 4.30371L15.7791 4.2207Z"></path>
          </svg>
        </span>
        <span>New Chat</span>
      </button>

      <button class="settings-btn" id="settingsBtn">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 15a3 3 0 100-6 3 3 0 000 6z"/>
          <path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z"/>
        </svg>
        <span>Settings</span>
      </button>
    </div>
  </header>

  <!-- Settings Panel -->
  <div class="settings-panel" id="settingsPanel">
    <div class="settings-header">
      <h3>⚙️ Settings</h3>
    </div>
    <div class="settings-content">
      
      <!-- Voice Mode Section -->
      <div class="settings-section">
        <div class="settings-section-title">Voice Mode</div>
        <div class="settings-item">
          <button class="voice-toggle-btn" id="voiceToggleBtn" title="Toggle voice mode" style="width: 100%; justify-content: center;">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
              <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
              <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
            </svg>
            <span>Voice Off</span>
          </button>
          <div class="settings-description">Enable voice input and text-to-speech</div>
        </div>
      </div>

      <!-- Model Selection Section -->
      <div class="settings-section">
        <div class="settings-section-title">AI Model</div>
        <div class="settings-item">
          <label class="settings-label">Select Model</label>
          <div class="model-selector" id="modelSelector">
            <button class="model-select-btn" id="modelSelectBtn" title="Select AI model" style="width: 100%;">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
              </svg>
              <span id="activeModelName">Loading...</span>
              <span class="model-dropdown-arrow">▼</span>
            </button>
            <div class="model-dropdown" id="modelDropdown">
              <div class="model-option" data-model="loading">
                <div class="model-info">
                  <div class="model-name">Loading models...</div>
                  <div class="model-provider">Please wait</div>
                </div>
              </div>
            </div>
          </div>
          <div class="settings-description">Choose which AI model to use for responses</div>
        </div>
      </div>

      <!-- Evaluation Section -->
      <div class="settings-section">
        <div class="settings-section-title">Evaluation Mode</div>
        <div class="settings-item">
          <div class="evaluation-toggle" style="justify-content: space-between; width: 100%;">
            <label style="font-weight: 600; color: #333;">
              Enable Evaluations
            </label>
            <div style="display: flex; align-items: center; gap: 10px;">
              <label class="toggle-switch">
                <input type="checkbox" id="evaluationToggle" checked onchange="toggleEvaluations()">
                <span class="toggle-slider"></span>
              </label>
              <span id="evaluationStatus" style="color: #4CAF50; font-size: 14px;">Enabled</span>
            </div>
          </div>
          <span id="evaluationLatency" style="color: #999; font-size: 12px; display: block; margin-top: 8px;"></span>
          <div class="settings-description">Run HealthBench and HELM evaluations (slower response times)</div>
        </div>
      </div>

      <!-- STT Provider Section -->
      <div class="settings-section">
        <div class="settings-section-title">Speech-to-Text (STT)</div>
        <div class="settings-item">
          <label class="settings-label">STT Provider</label>
          <select id="sttProviderSelect" style="width: 100%; padding: 10px; border: 1px solid #dee2e6; border-radius: 6px; font-family: inherit; font-size: 14px;">
            <option value="faster-whisper">Faster Whisper (3-4s, Offline)</option>
            <option value="deepgram">Deepgram Nova-2 (0.5s, Requires API Key)</option>
          </select>
          <div class="settings-description" id="sttProviderDescription">
            Current: Faster Whisper - Reliable, works offline, no API key needed
          </div>
          <div id="sttProviderStatus" style="margin-top: 8px; padding: 8px; border-radius: 4px; font-size: 12px; display: none;">
          </div>
        </div>
      </div>

    </div>
  </div>

  <div class="main-content">
    <div id="messages"></div>
  </div>

  <!-- Scroll to bottom button -->
  <button id="scroll-to-bottom-btn" title="Scroll to bottom">
    <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
      <path d="M9.33468 3.33333C9.33468 2.96617 9.6326 2.66847 9.99972 2.66829C10.367 2.66829 10.6648 2.96606 10.6648 3.33333V15.0609L15.363 10.3626L15.4675 10.2777C15.7255 10.1074 16.0762 10.1357 16.3034 10.3626C16.5631 10.6223 16.5631 11.0443 16.3034 11.304L10.4704 17.137C10.2108 17.3967 9.7897 17.3966 9.52999 17.137L3.69601 11.304L3.61105 11.1995C3.44054 10.9414 3.46874 10.5899 3.69601 10.3626C3.92328 10.1354 4.27479 10.1072 4.53292 10.2777L4.63741 10.3626L9.33468 15.0599V3.33333Z"></path>
    </svg>
  </button>

  <div id="input-container">
    <div class="input-wrapper">
      <div class="voice-status" id="voiceStatus"></div>
      <input type="text" id="user-input" placeholder="Type your question...">
      <button class="mic-btn disabled" id="micBtn" title="Push to talk">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
          <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
        </svg>
      </button>
      <button id="send-btn">
        <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg">
          <path fill="none" d="M0 0h24v24H0z"></path>
          <path d="M2.01 21 23 12 2.01 3 2 10l15 2-15 2z"></path>
        </svg>
      </button>
    </div>
  </div>

  <script>
    // ===== AUDIO QUEUE FOR STREAMING TTS =====
    class AudioQueue {
      constructor() {
        this.queue = [];
        this.isPlaying = false;
        this.currentAudio = null;
      }
      
      add(audioBase64) {
        // Convert base64 to blob URL
        try {
          const binaryString = atob(audioBase64);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          const blob = new Blob([bytes], { type: 'audio/wav' });
          const url = URL.createObjectURL(blob);
          
          this.queue.push(url);
          console.log('[TTS QUEUE] Added audio chunk, queue length:', this.queue.length);
          
          if (!this.isPlaying) {
            this.playNext();
          }
        } catch (error) {
          console.error('[TTS QUEUE] Error processing audio:', error);
        }
      }
      
      async playNext() {
        if (this.queue.length === 0) {
          this.isPlaying = false;
          console.log('[TTS QUEUE] Queue empty, stopping');
          return;
        }
        
        this.isPlaying = true;
        const audioUrl = this.queue.shift();
        
        try {
          this.currentAudio = new Audio(audioUrl);
          
          this.currentAudio.onended = () => {
            URL.revokeObjectURL(audioUrl); // Clean up blob URL
            console.log('[TTS QUEUE] Audio finished, playing next');
            this.playNext();
          };
          
          this.currentAudio.onerror = (error) => {
            console.error('[TTS QUEUE] Audio playback error:', error);
            URL.revokeObjectURL(audioUrl);
            this.playNext(); // Continue with next audio
          };
          
          await this.currentAudio.play();
          console.log('[TTS QUEUE] Playing audio chunk');
        } catch (error) {
          console.error('[TTS QUEUE] Error playing audio:', error);
          URL.revokeObjectURL(audioUrl);
          this.playNext(); // Continue with next audio
        }
      }
      
      stop() {
        // Stop current audio and clear queue
        if (this.currentAudio) {
          this.currentAudio.pause();
          this.currentAudio = null;
        }
        
        // Clean up all blob URLs in queue
        this.queue.forEach(url => URL.revokeObjectURL(url));
        this.queue = [];
        this.isPlaying = false;
        console.log('[TTS QUEUE] Stopped and cleared');
      }
    }
    
    // Initialize global audio queue
    const audioQueue = new AudioQueue();
    
    // ===== END AUDIO QUEUE =====
    
    // API Base URL configuration
    function getApiBase() {
      const protocol = window.location.protocol;
      const hostname = window.location.hostname;
      
      // If opened as file://, default to localhost backend
      if (protocol === 'file:' || !hostname || hostname === '') {
        return 'http://127.0.0.1:8002';
      }
      
      // Development environment
      if (hostname === 'localhost' || hostname === '127.0.0.1') {
        return 'http://127.0.0.1:8002';
      }
      
      // Default fallback - use current origin
      return window.location.origin;
    }

    const messagesDiv = document.getElementById("messages");
    const input = document.getElementById("user-input");
    const sendBtn = document.getElementById("send-btn");

    
    // Generate a FRESH session ID for each page load (new conversation)
    // This ensures each time user opens chatbot, it's a NEW session
    const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
    const timestamp = new Date().getTime().toString().slice(-6); // Last 6 digits of timestamp
    const randomId = Math.random().toString(36).substr(2, 6);
    let sessionId = `cf.conversation.${date}.${timestamp}${randomId}`;
    
    // Store the new session
    localStorage.setItem('chatbot_session_id', sessionId);
    
    // Timing helper function
    function logTiming(stepName, startTime) {
      const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
      console.log(`[TIMING] ${stepName}: ${elapsed}s`);
      return performance.now(); // Return new start time for chaining
    }
    
    // Flag to prevent duplicate greetings
    let greetingSent = false;

    // Helper function to remove edit button from previous user messages
    function removeAllEditButtons() {
      const allWrappers = messagesDiv.querySelectorAll('.user-message-wrapper');
      allWrappers.forEach(wrapper => {
        const editContainer = wrapper.querySelector('.edit-button-container');
        if (editContainer) {
          editContainer.remove();
        }
      });
    }

    function addMessage(content, sender) {
      if (sender === "user") {
        // Remove edit button from any previous user messages
        removeAllEditButtons();
        
        // For user messages, create wrapper with message and edit button below
        const wrapper = document.createElement("div");
        wrapper.className = "user-message-wrapper";
        wrapper.innerHTML = `
          <div class="message user">${content}</div>
          <div class="edit-button-container">
            <button class="edit-btn" onclick="editMessage(this)" title="Edit message">
              <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
              </svg>
            </button>
          </div>
        `;
        messagesDiv.appendChild(wrapper);
        // Message added
        scrollToBottom();
        return wrapper;
      } else {
        // For bot messages, keep simple structure
        const div = document.createElement("div");
        div.className = "message " + sender;
        div.innerText = content;
        messagesDiv.appendChild(div);
        // Message added
        scrollToBottom();
        return div;
      }
    }

    function addMessageHTML(content, sender, traceId = null) {
      const div = document.createElement("div");
      div.className = "message " + sender;
      
      if (sender === "bot") {
        // For bot messages, wrap content and add copy button + feedback buttons
        div.innerHTML = `
          <div class="message-content">${content}</div>
          <div class="feedback-buttons">
            <button class="copy-button" onclick="copyMessage(this)" title="Copy message">
              📋
            </button>
            <button class="feedback-btn thumbs-up" onclick="submitFeedback(this, 'thumbs_up')" title="Good response">
              👍
            </button>
            <button class="feedback-btn thumbs-down" onclick="submitFeedback(this, 'thumbs_down')" title="Bad response">
              👎
            </button>
            <span class="feedback-text"></span>
          </div>
        `;
        
        // Store trace_id if provided
        if (traceId) {
          div.dataset.traceId = traceId;
        }
      } else {
        // For user messages, keep as is
        div.innerHTML = content;
      }
      
      messagesDiv.appendChild(div);
      // Message HTML added
      scrollToBottom();
      return div;
    }

    function renderMarkdown(text) {
      if (typeof marked !== 'undefined') {
        return marked.parse(text);
      } else {
        // Fallback: basic markdown-like formatting
        return text
          .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
          .replace(/\*(.*?)\*/g, '<em>$1</em>')
          .replace(/`(.*?)`/g, '<code>$1</code>')
          .replace(/^### (.*$)/gim, '<h3>$1</h3>')
          .replace(/^## (.*$)/gim, '<h2>$1</h2>')
          .replace(/^# (.*$)/gim, '<h1>$1</h1>')
          .replace(/^\* (.*$)/gim, '<li>$1</li>')
          .replace(/^\d+\. (.*$)/gim, '<li>$1</li>')
          .replace(/\n/g, '<br>');
      }
    }

    // Scroll mode state management
    let scrollMode = 'auto'; // 'auto' or 'manual'
    let isStreaming = false; // Track if bot is currently streaming
    let userInteractionTimeout = null; // Debounce user interaction detection
    const scrollToBottomBtn = document.getElementById('scroll-to-bottom-btn');
    
    // Update button visibility based on mode
    function updateButtonVisibility() {
      if (scrollMode === 'manual') {
        scrollToBottomBtn.classList.add('show');
      } else {
        scrollToBottomBtn.classList.remove('show');
      }
    }
    
    function scrollToBottom() {
      // Only auto-scroll if in auto mode
      if (scrollMode !== 'auto') {
        // Skipping auto-scroll
        return;
      }
      
      // Use requestAnimationFrame to ensure DOM is updated before scrolling
      requestAnimationFrame(() => {
        // Scroll to the very bottom of the page
        window.scrollTo({
          top: document.body.scrollHeight,
          behavior: 'smooth' // Use smooth for better UX
        });
      });
    }
    
    // Check if user is at the bottom of the page
    function isAtBottom() {
      const scrollThreshold = 100; // pixels from bottom to be considered "at bottom"
      const atBottom = (window.innerHeight + window.scrollY) >= (document.body.scrollHeight - scrollThreshold);
      return atBottom;
    }
    
    // Handle user wheel/scroll gestures (actual user interaction)
    function handleUserScrollGesture(event) {
      // Only care if we're in auto mode (manual mode already stops scrolling)
      if (scrollMode !== 'auto') {
        return;
      }
      
      // User scroll detected
      
      // Check if user is scrolling up (negative deltaY)
      const scrollingUp = event.deltaY < 0;
      
      if (scrollingUp) {
        // User is trying to scroll up - switch to manual mode
        scrollMode = 'manual';
        updateButtonVisibility();
        // Switched to MANUAL mode
      }
    }
    
    // Handle touch scrolling on mobile
    let touchStartY = 0;
    function handleTouchStart(event) {
      if (event.touches.length > 0) {
        touchStartY = event.touches[0].clientY;
      }
    }
    
    function handleTouchMove(event) {
      if (scrollMode !== 'auto') {
        return;
      }
      
      if (event.touches.length > 0) {
        const touchEndY = event.touches[0].clientY;
        const deltaY = touchEndY - touchStartY;
        
        // Scrolling up has positive deltaY (finger moves down)
        if (deltaY > 10) {
          scrollMode = 'manual';
          updateButtonVisibility();
          // Switched to MANUAL mode (touch)
        }
      }
    }
    
    // Monitor scroll position to switch back to auto when at bottom
    function checkScrollPosition() {
      // Check if we're in manual mode and user scrolled to bottom
      // (works during streaming AND after streaming ends)
      if (scrollMode === 'manual' && isAtBottom()) {
        // User manually scrolled back to bottom - switch to auto
        scrollMode = 'auto';
        updateButtonVisibility();
        // Switched to AUTO mode
      }
    }
    
    // Handle scroll to bottom button click
    function handleScrollToBottomClick() {
      // Scroll button clicked
      scrollMode = 'auto';
      updateButtonVisibility();
      window.scrollTo({
        top: document.body.scrollHeight,
        behavior: 'smooth'
      });
    }
    
    // Add event listeners for user scroll gestures
    window.addEventListener('wheel', handleUserScrollGesture, { passive: true });
    window.addEventListener('touchstart', handleTouchStart, { passive: true });
    window.addEventListener('touchmove', handleTouchMove, { passive: true });
    
    // Check scroll position periodically to switch back to auto mode
    window.addEventListener('scroll', checkScrollPosition, { passive: true });
    
    // Add click event listener to scroll button
    scrollToBottomBtn.addEventListener('click', handleScrollToBottomClick);

    // Submit feedback functionality - sends to backend for Langfuse logging
    async function submitFeedback(button, rating) {
      try {
        const messageDiv = button.closest('.message.bot');
        const traceId = messageDiv.dataset.traceId || messageDiv.dataset.traceid;
        const generationId = messageDiv.dataset.generationId || messageDiv.dataset.generationid;
        
        // Check if feedback already submitted
        if (messageDiv.dataset.feedbackSubmitted === 'true') {
          // Feedback already submitted
          return;
        }
        
        // Disable all feedback buttons immediately to prevent double-clicking
        const feedbackButtons = messageDiv.querySelectorAll('.feedback-btn');
        feedbackButtons.forEach(btn => {
          btn.disabled = true;
          btn.style.cursor = 'not-allowed';
          btn.style.opacity = '0.5';
        });
        
        // Mark as submitted to prevent future submissions
        messageDiv.dataset.feedbackSubmitted = 'true';
        
        // Update UI to show which button was clicked
        feedbackButtons.forEach(btn => btn.classList.remove('selected'));
        button.classList.add('selected');
        
        // Show feedback text
        const feedbackText = messageDiv.querySelector('.feedback-text');
        feedbackText.textContent = 'Submitting...';
        
        // Send feedback to backend if trace_id exists
        if (traceId) {
          try {
            const apiBase = getApiBase();
            const feedbackPayload = {
              trace_id: traceId,
              rating: rating,
              comment: ""
            };
            
            // Add generation_id if available
            if (generationId) {
              feedbackPayload.generation_id = generationId;
            }
            
            const response = await fetch(`${apiBase}/feedback`, {
              method: "POST",
              headers: { 
                "Content-Type": "application/json"
              },
              body: JSON.stringify(feedbackPayload),
            });
            
            if (response.ok) {
              const data = await response.json();
              // Feedback submitted
              feedbackText.textContent = rating === 'thumbs_up' ? 'Thanks for your feedback!' : 'Thanks! We\'ll improve.';
            } else {
              console.error("Failed to submit feedback to backend");
              feedbackText.textContent = 'Feedback saved locally';
            }
          } catch (error) {
            console.error("Error submitting feedback to backend:", error);
            feedbackText.textContent = 'Feedback saved locally';
          }
        } else {
          feedbackText.textContent = rating === 'thumbs_up' ? 'Thanks for your feedback!' : 'Thanks! We\'ll improve.';
        }
        
        // Clear feedback text after 3 seconds
        setTimeout(() => {
          feedbackText.textContent = '';
        }, 3000);
        
      } catch (error) {
        console.error("Error submitting feedback:", error);
        
        // Re-enable buttons on error
        const messageDiv = button.closest('.message.bot');
        const feedbackButtons = messageDiv.querySelectorAll('.feedback-btn');
        feedbackButtons.forEach(btn => {
          btn.disabled = false;
          btn.style.cursor = 'pointer';
          btn.style.opacity = '1';
        });
        messageDiv.dataset.feedbackSubmitted = 'false';
      }
    }

    // Copy message functionality
    async function copyMessage(button) {
      try {
        // Get the message content (text only, without HTML)
        const messageDiv = button.closest('.message.bot');
        const contentDiv = messageDiv.querySelector('.message-content');
        
        // Extract text content from the HTML
        const textContent = contentDiv.textContent || contentDiv.innerText || '';
        
        // Copy to clipboard
        await navigator.clipboard.writeText(textContent);
        
        // Show success feedback
        const originalHTML = button.innerHTML;
        button.innerHTML = '<span style="color: #10a37f;">✓</span>';
        button.classList.add('copied');
        
        // Reset after 2 seconds
        setTimeout(() => {
          button.innerHTML = originalHTML;
          button.classList.remove('copied');
        }, 2000);
        
      } catch (err) {
        console.error('Failed to copy text: ', err);
        
        // Fallback: show error feedback
        const originalHTML = button.innerHTML;
        button.innerHTML = '<span style="color: #721c24;">❌</span>';
        button.style.background = '#f8d7da';
        
        // Reset after 2 seconds
        setTimeout(() => {
          button.innerHTML = originalHTML;
          button.style.background = '';
        }, 2000);
      }
    }

    // Auto-resize textarea to fit content
    function autoResizeTextarea(textarea) {
      textarea.style.height = 'auto';
      textarea.style.height = textarea.scrollHeight + 'px';
    }

    // Edit message functionality - inline editing
    function editMessage(button) {
      const wrapper = button.closest('.user-message-wrapper');
      const messageDiv = wrapper.querySelector('.message.user');
      const originalText = messageDiv.textContent || messageDiv.innerText || '';
      
      // Store original content and width for cancel
      wrapper.dataset.originalContent = originalText;
      const originalWidth = messageDiv.offsetWidth;
      wrapper.dataset.originalWidth = originalWidth;
      
      // Add editing class to wrapper
      wrapper.classList.add('editing');
      
      // Set minimum width to preserve message size
      messageDiv.style.minWidth = originalWidth + 'px';
      
      // Replace message content with textarea and buttons
      messageDiv.innerHTML = `<textarea class="edit-textarea" autofocus>${originalText}</textarea>`;
      
      // Hide edit button and add action buttons
      const editButtonContainer = wrapper.querySelector('.edit-button-container');
      editButtonContainer.style.display = 'none';
      
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'edit-actions';
      actionsDiv.innerHTML = `
        <button class="edit-action-btn edit-cancel-btn" onclick="cancelEdit(this)">Cancel</button>
        <button class="edit-action-btn edit-save-btn" onclick="saveEdit(this)">Save & Resend</button>
      `;
      wrapper.appendChild(actionsDiv);
      
      // Focus textarea and move cursor to end
      const textarea = messageDiv.querySelector('.edit-textarea');
      
      // Auto-resize textarea to fit content
      autoResizeTextarea(textarea);
      
      // Add input event listener for auto-resize
      textarea.addEventListener('input', () => autoResizeTextarea(textarea));
      
      textarea.focus();
      textarea.setSelectionRange(textarea.value.length, textarea.value.length);
      
      // Add keyboard shortcuts
      textarea.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          saveEdit(wrapper.querySelector('.edit-save-btn'));
        } else if (e.key === 'Escape') {
          e.preventDefault();
          cancelEdit(wrapper.querySelector('.edit-cancel-btn'));
        }
      });
    }

    // Cancel edit and restore original content
    function cancelEdit(button) {
      const wrapper = button.closest('.user-message-wrapper');
      const originalContent = wrapper.dataset.originalContent || '';
      const messageDiv = wrapper.querySelector('.message.user');
      
      // Remove editing class
      wrapper.classList.remove('editing');
      
      // Remove min-width constraint
      messageDiv.style.minWidth = '';
      
      // Restore original message content
      messageDiv.innerHTML = originalContent;
      
      // Remove action buttons
      const actionsDiv = wrapper.querySelector('.edit-actions');
      if (actionsDiv) {
        actionsDiv.remove();
      }
      
      // Show edit button again
      const editButtonContainer = wrapper.querySelector('.edit-button-container');
      if (editButtonContainer) {
        editButtonContainer.style.display = 'flex';
      }
    }

    // Save edited message and resend
    async function saveEdit(button) {
      const wrapper = button.closest('.user-message-wrapper');
      const textarea = wrapper.querySelector('.edit-textarea');
      const newText = textarea.value.trim();
      
      if (!newText) {
        alert('Message cannot be empty');
        return;
      }
      
      const messageDiv = wrapper.querySelector('.message.user');
      
      // Remove editing class
      wrapper.classList.remove('editing');
      
      // Remove min-width constraint
      messageDiv.style.minWidth = '';
      
      // Update message content with new text
      messageDiv.innerHTML = newText;
      
      // Remove action buttons
      const actionsDiv = wrapper.querySelector('.edit-actions');
      if (actionsDiv) {
        actionsDiv.remove();
      }
      
      // Show edit button again
      const editButtonContainer = wrapper.querySelector('.edit-button-container');
      if (editButtonContainer) {
        editButtonContainer.style.display = 'flex';
      }
      
      // Remove all messages after this one from DOM
      let nextSibling = wrapper.nextElementSibling;
      while (nextSibling) {
        const toRemove = nextSibling;
        nextSibling = nextSibling.nextElementSibling;
        toRemove.remove();
      }
      
      // Message edited
      
      // Update chat history on server
      await updateChatHistoryAfterEdit(wrapper, newText);
      
      // Resend the edited message
      await sendMessageText(newText);
    }
    
    // Update chat history on server after editing (simplified - no auth)
    async function updateChatHistoryAfterEdit(editedWrapper, editedText) {
      // For now, we'll just update local state
      // Server-side history updates are optional without authentication
      // Message edited locally
    }

    // Send message with specific text (used for editing)
    async function sendMessageText(questionText) {
      if (!questionText) return;
      
      const startTime = performance.now();
      console.log('[STEP] Generating Response from RAG...');
      
      // Store question in outer scope for tree branch logging
      const question = questionText;

      // Show thinking animation
      const botDiv = addMessageHTML("", "bot");
      botDiv.innerHTML = `
        <div class="thinking">
          Thinking
          <span class="thinking-dots">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
      `;

      // Force another scroll to ensure thinking is visible
      setTimeout(() => scrollToBottom(), 50);

      // Start streaming - enable scroll tracking
      isStreaming = true;
      scrollMode = 'auto'; // Reset to auto mode for new message
      updateButtonVisibility(); // Ensure button is hidden in auto mode
      try {
        const requestBody = { question };
        
        // Send session_id for session continuity
        requestBody.session_id = sessionId;
        
        // Use streaming endpoint for real-time responses
        const response = await fetch(`${getApiBase()}/chat/stream`, {
          method: "POST",
          headers: { 
            "Content-Type": "application/json"
          },
          body: JSON.stringify(requestBody),
        });

        // Response received
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        // Keep thinking animation until we get thinking_complete signal
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        let fullResponse = "";
        let lastRenderTime = 0;
        const renderThrottle = 16; // 60fps - re-render every 16ms for smooth streaming
        let receivedStreamingAudio = false; // Track if we got streaming audio chunks

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || ""; // Keep incomplete line in buffer
          
          for (const line of lines) {
            if (line.startsWith('data: ')) {
              try {
                const data = JSON.parse(line.slice(6));
                
                if (data.type === 'thinking_complete') {
                  // Clear thinking animation and prepare for streaming (NO BUTTONS YET)
                  botDiv.innerHTML = `<div class="message-content"></div>`;
                  // Thinking complete
                } else if (data.type === 'sources') {
                  // Log source information to browser console
                  // Sources received
                } else if (data.type === 'token') {
                  // Add token to response (STILL NO BUTTONS)
                  const token = data.token;
                  fullResponse += token;
                  
                  // Throttle rendering to improve performance
                  const now = Date.now();
                  if (now - lastRenderTime > renderThrottle) {
                    // Render markdown and update only the message content
                    const contentDiv = botDiv.querySelector('.message-content');
                    if (contentDiv) {
                      contentDiv.innerHTML = renderMarkdown(fullResponse);
                    } else {
                      // Fallback: create content div only
                      botDiv.innerHTML = `<div class="message-content">${renderMarkdown(fullResponse)}</div>`;
                    }
                    scrollToBottom();
                    lastRenderTime = now;
                  }
                } else if (data.type === 'audio_chunk') {
                  // Streaming TTS audio chunk received
                  console.log('[TTS STREAM] Received audio chunk for:', data.sentence?.substring(0, 50));
                  audioQueue.add(data.audio);
                  receivedStreamingAudio = true; // Mark that we got streaming audio
                } else if (data.type === 'done') {
                  // Final response received with trace_id, generation_id, and tree branch info
                  fullResponse = data.full_response || fullResponse;
                  const traceId = data.trace_id;
                  const generationId = data.generation_id;
                  const treeBranchInfo = data.tree_branch_info;
                  
                  // Log timing for RAG response generation
                  logTiming('RAG Response Generation', startTime);
                  
                  // Log tree branch info (simplified)
                  if (treeBranchInfo) {
                    console.log(`[RAG] Tree Branch: ${treeBranchInfo.tree_branch || 'Unknown'}`);
                    if (treeBranchInfo.tags && treeBranchInfo.tags.length > 0) {
                      console.log(`[RAG] Tags: ${treeBranchInfo.tags.join(', ')}`);
                    }
                  }
                  
                  // Check if response is empty
                  if (!fullResponse || fullResponse.trim() === '') {
                    console.error("[ERROR] Empty response received!");
                    fullResponse = "I apologize, but I wasn't able to generate a response. Please try again.";
                  }
                  
                  // UI Update timing
                  const uiStartTime = performance.now();
                  console.log('[STEP] Updating UI...');
                  
                  // Final render with complete response and buttons
                  botDiv.innerHTML = `
                    <div class="message-content">${renderMarkdown(fullResponse)}</div>
                    <div class="feedback-buttons">
                      <button class="copy-button" onclick="copyMessage(this)" title="Copy message">
                        📋
                      </button>
                      <button class="feedback-btn thumbs-up" onclick="submitFeedback(this, 'thumbs_up')" title="Good response">
                        👍
                      </button>
                      <button class="feedback-btn thumbs-down" onclick="submitFeedback(this, 'thumbs_down')" title="Bad response">
                        👎
                      </button>
                      <span class="feedback-text"></span>
                    </div>
                  `;
                  
                  logTiming('UI Update', uiStartTime);
                  
                  // Store trace_id and generation_id on the bot message for feedback
                  if (traceId) {
                    botDiv.dataset.traceId = traceId;
                  } else {
                    // Generate a fallback trace_id for feedback functionality
                    const fallbackTraceId = 'fallback_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    botDiv.dataset.traceId = fallbackTraceId;
                  }
                  
                  // Store generation_id if available
                  if (generationId) {
                    botDiv.dataset.generationId = generationId;
                  }
                  
                  // Note: Evaluations may run in background if enabled (check toggle)
                  let evalStartTime = performance.now();
                  
                  // End streaming - keep current mode (don't force to auto)
                  isStreaming = false;
                  
                  // If voice mode enabled, speak the response
                  // In hands-free mode, recording will auto-start after speaking completes
                  // Skip if we already played streaming TTS
                  if (voiceEnabled && fullResponse && !receivedStreamingAudio) {
                    await speakText(fullResponse);
                  } else if (receivedStreamingAudio) {
                    console.log('[TTS] Skipping full-text TTS - already played streaming audio');
                  } else if (voiceEnabled && isHandsFree && !isSpeaking) {
                    // If TTS is disabled but hands-free is on, restart recording immediately
                    setTimeout(() => {
                      if (voiceEnabled && isHandsFree && !isSpeaking && !isRecording) {
                        startRecording();
                      }
                    }, 500);
                  }
                  
                  // Continue reading stream for evaluation_complete event
                  // Don't return yet - wait for evaluation_complete
                } else if (data.type === 'evaluation_complete') {
                  // Evaluation completed - log timing
                  // Use backend duration if available, otherwise calculate from start time
                  if (data.duration !== undefined) {
                    console.log(`[TIMING] Evaluations: ${data.duration}s`);
                  } else {
                    logTiming('Evaluations', evalStartTime);
                  }
                  return; // Now we can return after evaluations complete
                } else if (data.type === 'error') {
                  throw new Error(data.error);
                }
              } catch (e) {
                console.error("[ERROR] Error parsing streaming data:", e);
              }
            }
          }
        }
        
      } catch (error) {
        logTiming('RAG Response Generation (FAILED)', startTime);
        console.error("[ERROR] Chat error:", error);
        // Clear thinking animation and show error
        botDiv.innerHTML = "Sorry, there was an error. Please try again.";
        
        // End streaming on error - keep current mode
        isStreaming = false;
      }
    }

    async function sendMessage() {
      const question = input.value.trim();
      if (!question) return;

      addMessage(question, "user");
      input.value = "";
      
      // Mark greeting as sent since user has started conversation
      greetingSent = true;
      
      // Send the message
      await sendMessageText(question);
    }

    sendBtn.addEventListener("click", sendMessage);
    input.addEventListener("keypress", (e) => { if (e.key === "Enter") sendMessage(); });

    // ===== VOICE FUNCTIONALITY =====
    
    // Voice state management
    let voiceEnabled = false;
    let isHandsFree = false; // Hands-free mode flag
    let isRecording = false;
    let isSpeaking = false;
    let mediaRecorder = null;
    let audioChunks = [];
    
    // STT Provider management
    let sttProvider = 'deepgram'; // Default STT provider (will be loaded from backend)
    
    // WebSocket for streaming STT (Deepgram)
    let socket = null;
    let useStreamingSTT = true; // Use Deepgram streaming by default
    let audioContext = null;
    let audioWorkletNode = null;
    let streamingTranscript = "";
    
    // Voice latency tracker - measures time from patient voice end to bot voice start
    // Similar to AssemblyAI's silence detection between speakers
    const voiceLatencyTracker = {
      patientSpeechEndTime: null, // When patient actually stopped speaking (silence started)
      botVoiceStartTime: null,
      isTracking: false,
      
      // Mark when patient's actual speech ends (when silence is detected, not when recording stops)
      markPatientSpeechEnd() {
        // This is called when volume drops below threshold (silence detected)
        this.patientSpeechEndTime = performance.now();
        this.isTracking = true;
        console.log('%c[LATENCY] Patient speech ended (silence detected)', 'color: #888; font-weight: normal;');
      },
      
      // Mark when bot starts speaking (when TTS playback begins)
      markBotVoiceStart() {
        if (!this.isTracking || !this.patientSpeechEndTime) {
          console.warn('%c[LATENCY] Bot voice started but no patient speech end time recorded', 'color: orange;');
          return;
        }
        
        this.botVoiceStartTime = performance.now();
        const latency = this.botVoiceStartTime - this.patientSpeechEndTime;
        const latencySeconds = (latency / 1000).toFixed(2);
        const latencyMs = latency.toFixed(0);
        
        // Display latency in RED with prominent styling
        console.log(
          `%c⏱️ VOICE LATENCY: ${latencySeconds}s (${latencyMs}ms)`,
          'color: red; font-size: 16px; font-weight: bold; background: #ffe6e6; padding: 4px 8px; border-radius: 4px;'
        );
        
        // Additional breakdown in smaller text
        console.log(
          `%c  Patient speech ended: ${this.patientSpeechEndTime.toFixed(2)}ms | Bot voice started: ${this.botVoiceStartTime.toFixed(2)}ms`,
          'color: #666; font-size: 12px;'
        );
        
        // Reset for next measurement
        this.reset();
      },
      
      // Reset tracker for next conversation turn
      reset() {
        this.patientSpeechEndTime = null;
        this.botVoiceStartTime = null;
        this.isTracking = false;
      },
      
      // Cancel tracking if something goes wrong
      cancel() {
        if (this.isTracking) {
          console.warn('%c[LATENCY] Tracking cancelled - resetting', 'color: orange;');
          this.reset();
        }
      }
    };
    let currentAudio = null;
    // let audioContext = null; // Already declared above for Deepgram streaming
    let analyserNode = null;
    let silenceDetectionInterval = null;
    
    const voiceToggleBtn = document.getElementById('voiceToggleBtn');
    const micBtn = document.getElementById('micBtn');
    const voiceStatus = document.getElementById('voiceStatus');
    
    // Initialize WebSocket for streaming STT
    function initializeWebSocket() {
      if (socket && socket.connected) {
        console.log('[WEBSOCKET] Already connected');
        return;
      }
      
      try {
        // Connect to WebSocket server
        socket = io(getApiBase(), {
          transports: ['websocket', 'polling'],
          upgrade: true
        });
        
        socket.on('connect', () => {
          console.log('[WEBSOCKET] ✅ Connected to server');
        });
        
        socket.on('disconnect', () => {
          console.log('[WEBSOCKET] Disconnected from server');
        });
        
        socket.on('transcription_started', (data) => {
          console.log('[DEEPGRAM] Transcription started');
          streamingTranscript = "";
        });
        
        socket.on('transcription_result', (data) => {
          console.log(`[DEEPGRAM] Transcript: "${data.transcript}" (final: ${data.is_final})`);
          
          if (data.is_final) {
            // Final transcript - send to chat
            streamingTranscript += " " + data.transcript;
            console.log(`[DEEPGRAM] ✅ Final transcript: "${streamingTranscript.trim()}"`);
            
            // Send the final transcript to chat
            const finalText = streamingTranscript.trim();
            if (finalText.length > 0) {
              sendMessageText(finalText);
            }
            
            streamingTranscript = "";
          } else {
            // Interim result - just for display (optional)
            console.log(`[DEEPGRAM] Interim: "${data.transcript}"`);
          }
        });
        
        socket.on('transcription_error', (data) => {
          console.error('[DEEPGRAM] Error:', data.error);
          // Fallback to regular STT
          useStreamingSTT = false;
        });
        
        socket.on('transcription_stopped', (data) => {
          console.log('[DEEPGRAM] Transcription stopped');
        });
        
        // NEW: Live transcription handlers
        socket.on('live_ready', (data) => {
          console.log('[LIVE STT] Live transcription ready');
        });
        
        socket.on('live_transcript', (data) => {
          const text = data.text || '';
          const isFinal = data.is_final || false;
          
          console.log(`[LIVE STT] ${isFinal ? 'FINAL' : 'INTERIM'}: "${text}"`);
          
          // Display interim results in the input box in real-time
          if (!isFinal) {
            // Show interim text with a visual indicator
            input.value = text + ' ...';
            input.style.fontStyle = 'italic';
            input.style.opacity = '0.7';
          } else {
            // Final text - restore normal style
            streamingTranscript += text + ' ';
            input.value = streamingTranscript.trim();
            input.style.fontStyle = 'normal';
            input.style.opacity = '1';
          }
        });
        
        socket.on('live_transcription_complete', (data) => {
          const finalText = data.text || streamingTranscript.trim();
          console.log(`[LIVE STT] ✅ Complete: "${finalText}"`);
          
          // Reset streaming flag
          streamingSessionActive = false;
          
          // Restore input style
          input.style.fontStyle = 'normal';
          input.style.opacity = '1';
          
          // Handle the final transcription
          if (finalText && finalText.length > 0) {
            handleTranscriptionResult(finalText);
          } else {
            // No transcription received - just restart recording in hands-free mode
            console.log('[LIVE STT] No transcription received, restarting recording');
            if (voiceEnabled && isHandsFree && !isSpeaking && !isRecording) {
              setTimeout(() => startRecording(), 300);
            }
          }
          
          // Reset
          streamingTranscript = "";
        });
        
      } catch (error) {
        console.error('[WEBSOCKET] Error initializing:', error);
        useStreamingSTT = false;
      }
    }
    
    // Check voice availability on page load
    async function checkVoiceAvailability() {
      try {
        const response = await fetch(`${getApiBase()}/voice/status`);
        const data = await response.json();
        
        // Check if STT is available (TTS is optional)
        if (data.initialized && data.stt_available) {
          // Voice available - enable toggle button
          voiceToggleBtn.disabled = false;
          
          // Update STT provider options based on availability
          if (data.stt_providers) {
            updateSTTProviderOptions(data.stt_providers);
            sttProvider = data.current_stt_provider || 'faster-whisper';
            document.getElementById('sttProviderSelect').value = sttProvider;
          }
        } else {
          voiceToggleBtn.disabled = true;
          voiceToggleBtn.title = 'Voice processing not available on server';
        }
      } catch (error) {
        console.error('[ERROR] Error checking voice availability:', error);
        voiceToggleBtn.disabled = true;
      }
    }
    
    // Update STT provider select options based on availability
    function updateSTTProviderOptions(providers) {
      const select = document.getElementById('sttProviderSelect');
      const whisperOption = select.querySelector('option[value="faster-whisper"]');
      const deepgramOption = select.querySelector('option[value="deepgram"]');
      
      // Update option text based on availability
      if (whisperOption) {
        whisperOption.disabled = !providers['faster-whisper']?.available;
        whisperOption.textContent = `Faster Whisper (3-4s, Offline)${!providers['faster-whisper']?.available ? ' - Unavailable' : ''}`;
      }
      
      if (deepgramOption) {
        deepgramOption.disabled = !providers['deepgram']?.available;
        deepgramOption.textContent = `Deepgram Nova-2 (0.5s)${!providers['deepgram']?.available ? ' - Requires API Key' : ''}`;
      }
    }
    
    // Handle STT provider change
    async function handleSTTProviderChange() {
      const select = document.getElementById('sttProviderSelect');
      const newProvider = select.value;
      const statusDiv = document.getElementById('sttProviderStatus');
      const descriptionDiv = document.getElementById('sttProviderDescription');
      
      console.log(`[STT] Switching to provider: ${newProvider}`);
      
      try {
        const response = await fetch(`${getApiBase()}/voice/stt-provider`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ provider: newProvider })
        });
        
        const data = await response.json();
        
        if (response.ok) {
          sttProvider = newProvider;
          statusDiv.style.display = 'block';
          statusDiv.style.backgroundColor = '#d4edda';
          statusDiv.style.color = '#155724';
          statusDiv.textContent = '✅ ' + data.message;
          
          // Update description
          if (newProvider === 'deepgram') {
            descriptionDiv.textContent = 'Current: Deepgram Nova-2 - Ultra-fast (0.5s), requires API key';
          } else {
            descriptionDiv.textContent = 'Current: Faster Whisper - Reliable, works offline, no API key needed';
          }
          
          // Hide status after 3 seconds
          setTimeout(() => {
            statusDiv.style.display = 'none';
          }, 3000);
        } else {
          statusDiv.style.display = 'block';
          statusDiv.style.backgroundColor = '#f8d7da';
          statusDiv.style.color = '#721c24';
          statusDiv.textContent = '❌ ' + (data.error || 'Failed to change STT provider');
          
          // Revert selection
          select.value = sttProvider;
        }
      } catch (error) {
        console.error('[STT] Error changing provider:', error);
        statusDiv.style.display = 'block';
        statusDiv.style.backgroundColor = '#f8d7da';
        statusDiv.style.color = '#721c24';
        statusDiv.textContent = '❌ Error: ' + error.message;
        
        // Revert selection
        select.value = sttProvider;
      }
    }
    
    // Check if getUserMedia is available
    function isGetUserMediaAvailable() {
      try {
        // Check for modern API first
        // Note: navigator.mediaDevices might be undefined in non-secure contexts
        if (navigator.mediaDevices && typeof navigator.mediaDevices.getUserMedia === 'function') {
          return true;
        }
        // Check for legacy API (deprecated but still used in some browsers)
        if (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia) {
          return true;
        }
        return false;
      } catch (e) {
        // If accessing navigator.mediaDevices throws an error, it's not available
        return false;
      }
    }
    
    // Get getUserMedia with fallback for older browsers
    function getUserMedia(constraints) {
      try {
        // Modern API
        if (navigator.mediaDevices && typeof navigator.mediaDevices.getUserMedia === 'function') {
          return navigator.mediaDevices.getUserMedia(constraints);
        }
        // Legacy API with promise wrapper
        const legacyGetUserMedia = navigator.getUserMedia || 
                                    navigator.webkitGetUserMedia || 
                                    navigator.mozGetUserMedia || 
                                    navigator.msGetUserMedia;
        
        if (legacyGetUserMedia) {
          return new Promise((resolve, reject) => {
            legacyGetUserMedia.call(navigator, constraints, resolve, reject);
          });
        }
      } catch (e) {
        console.error('[ERROR] Error accessing getUserMedia:', e);
      }
      
      // Not available
      throw new Error('getUserMedia is not supported in this browser');
    }
    
    // Check if secure context (HTTPS or localhost)
    function isSecureContext() {
      try {
        const protocol = window.location.protocol;
        const hostname = window.location.hostname;
        
        // Explicit check: HTTPS is always secure
        if (protocol === 'https:') {
          return true;
        }
        
        // Explicit check: localhost/127.0.0.1 are secure even on HTTP
        if (hostname === 'localhost' || hostname === '127.0.0.1' || hostname === '[::1]') {
          return true;
        }
        
        // For HTTP with IP address or domain name, check window.isSecureContext
        // This will be false for HTTP + IP address
        if (typeof window.isSecureContext !== 'undefined') {
          return window.isSecureContext;
        }
        
        // Default: if not HTTPS and not localhost, assume not secure
        return false;
      } catch (e) {
        // If we can't determine, assume not secure (safer)
        console.warn('[Voice] Error checking secure context:', e);
        return false;
      }
    }
    
    // Show voice countdown and auto-start
    function showVoiceCountdown() {
      const modal = document.getElementById('voiceCountdownModal');
      const countdownNumber = document.getElementById('countdownNumber');
      if (!modal || !countdownNumber) return;
      
      modal.classList.add('show');
      
      let countdown = 3;
      countdownNumber.textContent = countdown;
      
      const countdownInterval = setInterval(() => {
        countdown--;
        if (countdown > 0) {
          countdownNumber.textContent = countdown;
        } else {
          clearInterval(countdownInterval);
          modal.classList.remove('show');
          // Auto-start voice mode
          enableHandsFreeMode();
        }
      }, 1000);
    }

    // Hide voice countdown modal
    function hideVoiceCountdown() {
      const modal = document.getElementById('voiceCountdownModal');
      if (modal) {
        modal.classList.remove('show');
      }
    }

    // Start session after modal choice
    async function startSessionAfterModalChoice() {
      // Only send greeting if no messages are displayed and greeting hasn't been sent
      if (messagesDiv.children.length === 0 && !greetingSent) {
        await sendInitialGreeting();
      }
    }

    // Enable hands-free mode after confirmation
    async function enableHandsFreeMode() {
      hideVoiceCountdown();
      voiceEnabled = true;
      isHandsFree = true;
      
      // Initialize WebSocket for streaming STT
      initializeWebSocket();
      
      voiceToggleBtn.classList.add('active');
      voiceToggleBtn.querySelector('span').textContent = 'Voice On';
      micBtn.classList.remove('disabled');
      
      // Update mic button to show it's always-on
      micBtn.title = 'Hands-free mode active - microphone always on';
      
      // Start the session (send greeting)
      await startSessionAfterModalChoice();
      
      // Start recording immediately in hands-free mode
      try {
        await startRecording();
      } catch (error) {
        console.error('[ERROR] Failed to start hands-free recording:', error);
        // If recording fails, disable hands-free mode
        voiceEnabled = false;
        isHandsFree = false;
        voiceToggleBtn.classList.remove('active');
        voiceToggleBtn.querySelector('span').textContent = 'Voice Off';
        micBtn.classList.add('disabled');
        alert('Failed to start hands-free mode. Please try again.');
      }
    }

    // Toggle voice mode
    async function toggleVoiceMode() {
      // If disabling voice mode
      if (voiceEnabled) {
        voiceEnabled = false;
        isHandsFree = false;
        voiceToggleBtn.classList.remove('active');
        voiceToggleBtn.querySelector('span').textContent = 'Voice Off';
        micBtn.classList.add('disabled');
        micBtn.title = 'Push to talk';
        stopRecording(); // Stop if currently recording
        stopSpeaking(); // Stop if currently speaking
        return;
      }
      
      // If enabling voice mode - show confirmation modal
      // Check if secure context FIRST (required for getUserMedia)
      if (!isSecureContext()) {
        console.error('[ERROR] getUserMedia requires HTTPS or localhost');
        const protocol = window.location.protocol;
        const hostname = window.location.hostname;
        let message = 'Voice mode requires a secure connection (HTTPS) or localhost.\n\n';
        
        if (protocol === 'http:' && hostname !== 'localhost' && hostname !== '127.0.0.1') {
          message += 'You are accessing the site over HTTP from an IP address.\n';
          message += 'To use voice features:\n';
          message += '1. Access via localhost: http://localhost:8003\n';
          message += '2. Or set up HTTPS in production';
        } else {
          message += 'Please access the site over HTTPS or use localhost.';
        }
        
        alert(message);
        return;
      }
      
      // Check if getUserMedia is available (only after secure context check)
      if (!isGetUserMediaAvailable()) {
        console.error('[ERROR] getUserMedia is not supported in this browser');
        alert('Voice mode is not supported in this browser. Please use a modern browser like Chrome, Firefox, or Edge.');
        return;
      }
      
      // Check microphone permission
      try {
        const stream = await getUserMedia({ audio: true });
        stream.getTracks().forEach(track => track.stop()); // Stop immediately, just checking permission
        
        // Show confirmation modal
        showVoiceCountdown();
      } catch (error) {
        console.error('[ERROR] Microphone permission denied:', error);
        let errorMessage = 'Microphone permission is required for voice mode.';
        
        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
          errorMessage = 'Microphone permission was denied. Please allow microphone access in your browser settings and try again.';
        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
          errorMessage = 'No microphone found. Please connect a microphone and try again.';
        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
          errorMessage = 'Microphone is already in use by another application. Please close other applications using the microphone.';
        } else if (error.name === 'OverconstrainedError' || error.name === 'ConstraintNotSatisfiedError') {
          errorMessage = 'Microphone constraints could not be satisfied. Please check your microphone settings.';
        }
        
        alert(errorMessage);
      }
    }
    
    // Silence detection using Web Audio API
    function startSilenceDetection(stream) {
      if (!isHandsFree) return; // Only use silence detection in hands-free mode
      
      try {
        // Create audio context and analyser
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyserNode = audioContext.createAnalyser();
        analyserNode.fftSize = 256;
        analyserNode.smoothingTimeConstant = 0.8;
        
        const source = audioContext.createMediaStreamSource(stream);
        source.connect(analyserNode);
        
        const dataArray = new Uint8Array(analyserNode.frequencyBinCount);
        let isSpeaking = false;
        let silenceStartTime = null;
        let speechStartTime = null;
        let hasDetectedSpeech = false; // Track if any real speech was detected
        const SILENCE_THRESHOLD = 45; // Higher threshold to filter out background noise (0-255)
        const SILENCE_DURATION = 800; // 0.8 seconds of silence to stop (faster response)
        const MIN_SPEECH_DURATION = 400; // Minimum 400ms of speech to avoid capturing quick noises
        let lastCheckTime = Date.now();
        
        const checkVolume = () => {
          if (!isRecording || !isHandsFree) {
            if (silenceDetectionInterval) {
              clearInterval(silenceDetectionInterval);
              silenceDetectionInterval = null;
            }
            return;
          }
          
          analyserNode.getByteFrequencyData(dataArray);
          
          // Calculate average volume
          let sum = 0;
          for (let i = 0; i < dataArray.length; i++) {
            sum += dataArray[i];
          }
          const averageVolume = sum / dataArray.length;
          
          const now = Date.now();
          
          if (averageVolume > SILENCE_THRESHOLD) {
            // User is speaking
            if (!isSpeaking) {
              isSpeaking = true;
              speechStartTime = now; // Track when speech started
              silenceStartTime = null;
            }
            // Mark that we detected actual speech (not just initial noise)
            if (now - speechStartTime > MIN_SPEECH_DURATION) {
              hasDetectedSpeech = true;
            }
          } else {
            // Silence detected
            if (isSpeaking) {
              // Check if this was just a quick noise (less than MIN_SPEECH_DURATION)
              const speechDuration = now - (speechStartTime || now);
              
              if (speechDuration < MIN_SPEECH_DURATION) {
                // Too short - likely just noise, ignore it and DON'T stop recording
                console.log('[VOICE] Ignoring short noise burst, continuing to listen');
                isSpeaking = false;
                speechStartTime = null;
                silenceStartTime = null;
                hasDetectedSpeech = false;
                return;
              }
              
              // User was speaking (for long enough), now silence
              if (silenceStartTime === null) {
                // First moment of silence detected - mark this as speech end time
                silenceStartTime = now;
                voiceLatencyTracker.markPatientSpeechEnd();
              } else if (now - silenceStartTime >= SILENCE_DURATION) {
                // Only stop if we actually detected real speech
                if (hasDetectedSpeech) {
                  console.log('[VOICE] Real speech detected, stopping recording');
                  isSpeaking = false;
                  silenceStartTime = null;
                  speechStartTime = null;
                  hasDetectedSpeech = false;
                  stopRecording();
                  return;
                } else {
                  // No real speech detected, just reset and keep listening
                  console.log('[VOICE] No real speech detected, continuing to listen');
                  isSpeaking = false;
                  silenceStartTime = null;
                  speechStartTime = null;
                  return;
                }
              }
            }
          }
          
          lastCheckTime = now;
        };
        
        // Check volume every 100ms
        silenceDetectionInterval = setInterval(checkVolume, 100);
      } catch (error) {
        console.error('[ERROR] Silence detection error:', error);
        // Continue without silence detection if it fails
      }
    }

    // Stop silence detection
    function stopSilenceDetection() {
      if (silenceDetectionInterval) {
        clearInterval(silenceDetectionInterval);
        silenceDetectionInterval = null;
      }
      
      if (audioContext) {
        try {
          audioContext.close();
        } catch (e) {
          // Ignore errors when closing
        }
        audioContext = null;
      }
      
      analyserNode = null;
    }

    // Start recording
    async function startRecording() {
      if (!voiceEnabled || isRecording || isSpeaking) return;
      
      // Cancel previous tracking if exists (new recording starting before bot spoke)
      voiceLatencyTracker.cancel();
      
      // Check if getUserMedia is available
      if (!isGetUserMediaAvailable()) {
        console.error('[ERROR] getUserMedia is not supported');
        alert('Voice recording is not supported in this browser.');
        return;
      }
      
      try {
        const stream = await getUserMedia({ audio: true });
        
        // Create MediaRecorder with standard settings
        // For live streaming, we'll use Web Audio API separately
        mediaRecorder = new MediaRecorder(stream, {
          mimeType: 'audio/webm;codecs=opus',
          audioBitsPerSecond: 64000
        });
        
        audioChunks = [];
        
        // NEW: Set up Web Audio API for PCM streaming to Deepgram
        if (sttProvider === 'deepgram' && socket && socket.connected && !streamingSessionActive) {
          console.log('[LIVE STT] Starting live transcription session');
          streamingSessionActive = true; // Mark session as active
          
          socket.emit('start_live_transcription', {
            session_id: sessionId
          });
          
          // Set up AudioContext for real-time PCM streaming
          const audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
          const source = audioContext.createMediaStreamSource(stream);
          const processor = audioContext.createScriptProcessor(2048, 1, 1); // Smaller buffer = faster streaming (128ms)
          
          processor.onaudioprocess = (e) => {
            // Get PCM audio data
            const inputData = e.inputBuffer.getChannelData(0);
            
            // Convert Float32Array to Int16Array (PCM 16-bit)
            const pcm16 = new Int16Array(inputData.length);
            for (let i = 0; i < inputData.length; i++) {
              const s = Math.max(-1, Math.min(1, inputData[i]));
              pcm16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            
            // Convert to base64 and send immediately
            const uint8Array = new Uint8Array(pcm16.buffer);
            const base64Audio = btoa(String.fromCharCode.apply(null, uint8Array));
            
            socket.emit('live_audio_data', {
              audio: base64Audio,
              session_id: sessionId
            });
          };
          
          source.connect(processor);
          processor.connect(audioContext.destination);
          
          // Store for cleanup
          window.liveAudioContext = audioContext;
          window.liveAudioProcessor = processor;
          window.liveAudioSource = source;
        }
        
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
          }
        };
        
        mediaRecorder.onstop = async () => {
          // In hands-free mode, speech end time was already marked by silence detection
          // In normal mode (push-to-talk), mark it now
          if (!isHandsFree) {
            voiceLatencyTracker.markPatientSpeechEnd();
          }
          
          // Stop silence detection
          stopSilenceDetection();
          
          // Clean up Web Audio API if used
          if (window.liveAudioContext) {
            try {
              if (window.liveAudioProcessor) {
                window.liveAudioProcessor.disconnect();
              }
              if (window.liveAudioSource) {
                window.liveAudioSource.disconnect();
              }
              window.liveAudioContext.close();
              window.liveAudioContext = null;
              window.liveAudioProcessor = null;
              window.liveAudioSource = null;
            } catch (e) {
              console.error('[LIVE STT] Error cleaning up audio context:', e);
            }
          }
          
          // Create audio blob
          const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
          
          // Stop all tracks
          stream.getTracks().forEach(track => track.stop());
          
          // Stop live transcription if using Deepgram
          if (sttProvider === 'deepgram' && socket && socket.connected) {
            console.log('[LIVE STT] Stopping live transcription');
            streamingSessionActive = false; // Reset flag
            socket.emit('stop_live_transcription', {
              session_id: sessionId
            });
            // Don't call transcribeAudio - live transcription already handled it
          } else {
            // Fallback to regular transcription
            await transcribeAudio(audioBlob);
          }
        };
        
        // Start recording (collect for fallback)
        mediaRecorder.start();
        isRecording = true;
        
        // Update UI
        if (isHandsFree) {
          micBtn.classList.add('recording');
          voiceStatus.textContent = '🎤 Listening...';
        } else {
          micBtn.classList.add('recording');
          voiceStatus.textContent = '🔴 Recording...';
        }
        voiceStatus.classList.add('show', 'recording');
        
        // Start silence detection if in hands-free mode
        if (isHandsFree) {
          startSilenceDetection(stream);
        }
        
        // Auto-stop after 60 seconds (safety limit)
        setTimeout(() => {
          if (isRecording) {
            stopRecording();
          }
        }, 60000);
        
      } catch (error) {
        console.error('[ERROR] Recording error:', error);
        alert('Error accessing microphone. Please check permissions.');
        isRecording = false;
        stopSilenceDetection();
      }
    }
    
    // Stop recording
    function stopRecording() {
      if (!isRecording || !mediaRecorder) return;
      
      try {
        // In normal mode (push-to-talk), mark speech end when button is released
        // In hands-free mode, this was already marked by silence detection
        if (!isHandsFree && !voiceLatencyTracker.isTracking) {
          voiceLatencyTracker.markPatientSpeechEnd();
        }
        
        // Stop silence detection
        stopSilenceDetection();
        
        mediaRecorder.stop();
        isRecording = false;
        
        // Update UI
        micBtn.classList.remove('recording');
        voiceStatus.textContent = '⏳ Transcribing...';
        voiceStatus.classList.remove('recording');
        voiceStatus.classList.add('transcribing');
      } catch (error) {
        console.error('[ERROR] Stop recording error:', error);
        stopSilenceDetection();
      }
    }
    
    // Global variables for streaming
    let streamingTranscription = false;
    let streamingSessionActive = false;
    
    // Transcribe audio
    async function transcribeAudio(audioBlob) {
      const overallStart = performance.now();
      console.log('[STEP] Converting Speech to Text...');
      console.log(`[TIMING] Audio blob size: ${audioBlob.size} bytes`);
      
      try {
        voiceStatus.textContent = '⏳ Transcribing...';
        voiceStatus.classList.add('show', 'transcribing');
        
        // Check if we should use streaming (always for Deepgram)
        if (sttProvider === 'deepgram' && socket && socket.connected) {
          console.log('[STT] Using Deepgram WebSocket streaming');
          return await transcribeAudioStreaming(audioBlob, overallStart);
        }
        
        // Fallback to regular REST API
        const formDataStart = performance.now();
        const formData = new FormData();
        formData.append('audio', audioBlob, 'recording.webm');
        formData.append('session_id', sessionId);
        formData.append('stt_provider', sttProvider); // Pass selected STT provider
        console.log(`[TIMING] FormData prep: ${(performance.now() - formDataStart).toFixed(0)}ms`);
        
        console.log(`[STT] Using provider: ${sttProvider}`);
        
        const fetchStart = performance.now();
        const response = await fetch(`${getApiBase()}/voice/transcribe`, {
          method: 'POST',
          body: formData
        });
        const fetchTime = performance.now() - fetchStart;
        console.log(`[TIMING] ⏱️  NETWORK + BACKEND: ${fetchTime.toFixed(0)}ms`);
        
        if (!response.ok) {
          throw new Error(`Transcription failed: ${response.status}`);
        }
        
        const data = await response.json();
        const transcribedText = data.text;
        const usedProvider = data.stt_provider || sttProvider;
        
        const totalTime = performance.now() - overallStart;
        console.log(`[STT] ✅ Transcription complete using ${usedProvider}: "${transcribedText.substring(0, 50)}..."`);
        console.log(`[TIMING] ⏱️  TOTAL CLIENT STT: ${totalTime.toFixed(0)}ms`);
        
        // Hide status
        voiceStatus.classList.remove('show', 'transcribing');
        
        logTiming('Speech to Text', overallStart);
        
        // Handle the transcribed text
        await handleTranscriptionResult(transcribedText);
        
      } catch (error) {
        logTiming('Speech to Text (FAILED)', overallStart);
        console.error('[ERROR] Transcription error:', error);
        // Cancel latency tracking on transcription failure
        voiceLatencyTracker.cancel();
        voiceStatus.textContent = '❌ Transcription failed';
        voiceStatus.classList.add('show');
        setTimeout(() => {
          voiceStatus.classList.remove('show');
        }, 3000);
        alert('Transcription failed. Please try again or type your message.');
      }
    }
    
    // Streaming transcription using WebSocket
    async function transcribeAudioStreaming(audioBlob, startTime) {
      return new Promise((resolve, reject) => {
        console.log('[STT STREAMING] Starting WebSocket streaming transcription');
        
        // Start streaming session
        socket.emit('start_streaming_transcription', {
          session_id: sessionId
        });
        
        // Listen for streaming ready
        socket.once('streaming_ready', async (data) => {
          console.log('[STT STREAMING] Stream ready, sending audio chunks');
          
          try {
            // Convert blob to array buffer
            const arrayBuffer = await audioBlob.arrayBuffer();
            const audioData = new Uint8Array(arrayBuffer);
            
            // Send audio in chunks
            const CHUNK_SIZE = 8192; // 8KB chunks
            const totalChunks = Math.ceil(audioData.length / CHUNK_SIZE);
            
            console.log(`[STT STREAMING] Sending ${totalChunks} chunks (${audioData.length} bytes total)`);
            
            for (let i = 0; i < totalChunks; i++) {
              const start = i * CHUNK_SIZE;
              const end = Math.min(start + CHUNK_SIZE, audioData.length);
              const chunk = audioData.slice(start, end);
              
              // Convert to base64
              const base64Chunk = btoa(String.fromCharCode.apply(null, chunk));
              
              const isFinal = (i === totalChunks - 1);
              
              // Send chunk via WebSocket
              socket.emit('audio_chunk', {
                audio: base64Chunk,
                final: isFinal,
                session_id: sessionId,
                chunk_index: i,
                total_chunks: totalChunks
              });
              
              // Small delay between chunks to avoid overwhelming the server
              if (!isFinal) {
                await new Promise(r => setTimeout(r, 10));
              }
            }
            
            console.log('[STT STREAMING] All chunks sent, waiting for transcription...');
            
          } catch (error) {
            console.error('[STT STREAMING] Error sending audio:', error);
            reject(error);
          }
        });
        
        // Listen for transcription result
        socket.once('transcription_result', (data) => {
          const totalTime = performance.now() - startTime;
          const transcribedText = data.text || '';
          
          console.log(`[STT STREAMING] ✅ Transcription complete: "${transcribedText.substring(0, 50)}..."`);
          console.log(`[TIMING] ⏱️  TOTAL STREAMING STT: ${totalTime.toFixed(0)}ms`);
          
          // Hide status
          voiceStatus.classList.remove('show', 'transcribing');
          
          logTiming('Speech to Text (Streaming)', startTime);
          
          // Handle the transcribed text
          handleTranscriptionResult(transcribedText);
          
          resolve();
        });
        
        // Listen for errors
        socket.once('transcription_error', (data) => {
          console.error('[STT STREAMING] Error:', data.error);
          
          // Fall back to regular REST API
          console.log('[STT STREAMING] Falling back to REST API');
          voiceStatus.classList.remove('show', 'transcribing');
          reject(new Error(data.error));
        });
        
        // Timeout after 30 seconds
        setTimeout(() => {
          reject(new Error('Streaming transcription timeout'));
        }, 30000);
      });
    }
    
    // Handle transcription result (used by both regular and streaming)
    async function handleTranscriptionResult(transcribedText) {
      // Validate transcribed text
      if (!transcribedText || transcribedText === 'undefined' || transcribedText.trim().length === 0) {
        console.warn('[STT] Empty or invalid transcription, skipping');
        // Restart recording in hands-free mode even if transcription failed
        if (voiceEnabled && isHandsFree && !isSpeaking && !isRecording) {
          setTimeout(() => startRecording(), 500);
        }
        return;
      }
      
      console.log(`[STT] Handling transcription: "${transcribedText}" (Hands-free: ${isHandsFree})`);
      
      // In hands-free mode, auto-send if text is valid
      if (isHandsFree && transcribedText && transcribedText.trim().length > 0) {
        // Minimum length check to avoid sending noise
        if (transcribedText.trim().length >= 2) {
          // Auto-send the transcribed text
          console.log('[STT] Auto-sending in hands-free mode');
          input.value = transcribedText;
          await sendMessage();
          
          // Restart recording after message is sent (in hands-free mode)
          if (voiceEnabled && isHandsFree && !isSpeaking) {
            console.log('[STT] Restarting recording in hands-free mode');
            setTimeout(() => startRecording(), 500);
          }
        } else {
          // Text too short, just put it in input for user to see
          console.log('[STT] Text too short, not auto-sending');
          input.value = transcribedText;
          input.focus();
          // Restart recording in hands-free mode
          if (voiceEnabled && isHandsFree && !isSpeaking) {
            setTimeout(() => startRecording(), 500);
          }
        }
      } else {
        // Normal mode - put transcribed text in input box for user to review/edit
        console.log('[STT] Manual mode - text in input box');
        input.value = transcribedText;
        input.focus();
      }
    }
    
    // Strip markdown formatting for TTS (convert to plain text)
    function stripMarkdownForTTS(text) {
      if (!text) return '';
      
      // First, try to extract plain text if it's HTML
      let plainText = text;
      
      // Check if text contains HTML tags
      if (text.includes('<') && text.includes('>')) {
        // If text contains HTML tags (from markdown rendering), extract text content
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = text;
        plainText = tempDiv.textContent || tempDiv.innerText || text;
      }
      
      // Remove markdown formatting patterns (but preserve the text content)
      plainText = plainText
        // Remove horizontal rules (entire lines)
        .replace(/^---+$/gm, '')
        // Remove markdown headers (# ## ###) - but keep the text after
        .replace(/^#{1,6}\s+/gm, '')
        // Remove bold/italic markers (keep content)
        .replace(/\*\*([^*]+)\*\*/g, '$1')
        .replace(/\*([^*]+)\*/g, '$1')
        .replace(/__([^_]+)__/g, '$1')
        .replace(/_([^_]+)_/g, '$1')
        // Remove code blocks (entire blocks)
        .replace(/```[\s\S]*?```/g, '')
        .replace(/`([^`]+)`/g, '$1')
        // Remove links [text](url) -> text
        .replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1')
        // Remove images ![alt](url) -> alt
        .replace(/!\[([^\]]*)\]\([^\)]+\)/g, '$1')
        // Clean up list markers (convert to natural speech)
        .replace(/^[\s]*[-*+]\s+/gm, '')
        .replace(/^\d+\.\s+/gm, '');
      
      // Convert common markdown patterns to natural speech
      plainText = plainText.replace(/\*\*([^*:]+):\*\*/g, '$1:');
      
      // Clean up whitespace (but preserve word boundaries)
      plainText = plainText
        .replace(/\n{3,}/g, '\n\n')  // Multiple newlines to double
        .replace(/[ \t]+/g, ' ')      // Multiple spaces to single
        .trim();                       // Trim start/end
      
      // Add pauses for better speech flow (after cleaning)
      plainText = plainText
        .replace(/\n\n/g, '. ')
        .replace(/\n/g, '. ')
        .replace(/\.\s*\./g, '.')
        .replace(/\s+/g, ' ')
        .trim();
      
      // Ensure we have text and it starts properly
      if (!plainText || plainText.length === 0) {
        return '';
      }
      
      // Final cleanup: ensure first character is not a space or punctuation (unless intentional)
      // This helps prevent TTS from skipping the first word
      plainText = plainText.replace(/^[\s\.]+/, '').trim();
      
      return plainText;
    }
    
    // Text-to-speech for bot responses - Using Browser Web Speech API
    async function speakText(text) {
      if (!voiceEnabled || isSpeaking) {
        return;
      }
      
      // Check if browser supports Speech Synthesis
      if (!('speechSynthesis' in window)) {
        console.error('[ERROR] Browser does not support Speech Synthesis');
        return;
      }
      
      const startTime = performance.now();
      console.log('[STEP] Converting Text to Speech...');
      
      try {
        // Strip markdown formatting before speaking
        const plainText = stripMarkdownForTTS(text);
        
        if (!plainText || plainText.trim().length === 0) {
          return;
        }
        
        // Cancel any ongoing speech first to prevent conflicts
        speechSynthesis.cancel();
        
        // Wait longer to ensure cancellation is fully processed
        // This prevents the TTS engine from skipping the first word
        await new Promise(resolve => setTimeout(resolve, 200));
        
        isSpeaking = true;
        
        // Disable mic while bot is speaking
        micBtn.classList.add('disabled');
        voiceStatus.textContent = '🔊 Bot speaking...';
        voiceStatus.classList.add('show', 'speaking');
        
        // Ensure voices are loaded (some browsers load them asynchronously)
        let voices = speechSynthesis.getVoices();
        if (voices.length === 0) {
          // Wait for voices to load
          await new Promise(resolve => {
            const checkVoices = () => {
              voices = speechSynthesis.getVoices();
              if (voices.length > 0) {
                resolve();
              } else {
                // Some browsers fire voiceschanged event
                speechSynthesis.onvoiceschanged = () => {
                  voices = speechSynthesis.getVoices();
                  if (voices.length > 0) {
                    speechSynthesis.onvoiceschanged = null;
                    resolve();
                  }
                };
                // Fallback timeout
                setTimeout(resolve, 500);
              }
            };
            checkVoices();
          });
          voices = speechSynthesis.getVoices();
        }
        
        // Create speech utterance with plain text (no markdown)
        const utterance = new SpeechSynthesisUtterance(plainText);
        utterance.rate = 1.0;  // Normal speed
        utterance.pitch = 1.0;  // Normal pitch
        utterance.volume = 1.0;  // Full volume
        utterance.lang = 'en-US';
        
        // Try to get a good voice
        if (voices.length > 0) {
          // Prefer female voice or clear voice
          const preferredVoice = voices.find(v => 
            v.lang.startsWith('en') && (
              v.name.includes('Female') || 
              v.name.includes('Zira') || 
              v.name.includes('Google US English Female')
            )
          ) || voices.find(v => v.lang.startsWith('en'));
          
          if (preferredVoice) {
            utterance.voice = preferredVoice;
          }
        }
        
        // Set up event handlers BEFORE calling speak()
        utterance.onstart = () => {
          // Mark bot voice start timestamp and calculate latency
          voiceLatencyTracker.markBotVoiceStart();
          
          // TTS started speaking (playback begins)
          
          // STOP RECORDING TO PREVENT ECHO/FEEDBACK
          if (isRecording && isHandsFree) {
            console.log('[VOICE] Stopping mic to prevent bot voice echo');
            stopRecording();
          }
        };
        
        utterance.onend = () => {
          // Speech playback completed (not logging timing here - only processing time matters)
          stopSpeaking();
          
          // In hands-free mode, auto-start recording after bot finishes speaking
          if (voiceEnabled && isHandsFree) {
            micBtn.classList.remove('disabled');
            // Reduced delay for faster response (300ms instead of 500ms)
            setTimeout(() => {
              if (voiceEnabled && isHandsFree && !isSpeaking && !isRecording) {
                startRecording();
              }
            }, 100);
          } else if (voiceEnabled) {
            // Normal mode - just show status
            micBtn.classList.remove('disabled');
            voiceStatus.textContent = '🎤 Your turn';
            voiceStatus.classList.add('show');
            setTimeout(() => {
              voiceStatus.classList.remove('show');
            }, 2000);
          }
        };
        
        utterance.onerror = (error) => {
          logTiming('Text to Speech (FAILED)', startTime);
          console.error('[ERROR] Speech synthesis error:', error);
          // Cancel latency tracking on TTS failure
          voiceLatencyTracker.cancel();
          stopSpeaking();
        };
        
        // Verify utterance text is correct before speaking
        if (utterance.text !== plainText) {
          utterance.text = plainText;
        }
        
        // Longer delay to ensure utterance is fully configured and TTS engine is ready
        // This helps prevent the first word from being skipped
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Double-check text is still correct
        if (utterance.text !== plainText) {
          utterance.text = plainText;
        }
        
        // Speak the text - processing is complete at this point
        speechSynthesis.speak(utterance);
        
        // Log timing immediately after speak() is called (processing time only, not playback)
        logTiming('Text to Speech', startTime);
        
      } catch (error) {
        logTiming('Text to Speech (FAILED)', startTime);
        console.error('[ERROR] TTS error:', error);
        // Cancel latency tracking on TTS failure
        voiceLatencyTracker.cancel();
        stopSpeaking();
      }
    }
    
    // Stop speaking
    function stopSpeaking() {
      if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
      }
      
      isSpeaking = false;
      voiceStatus.classList.remove('show', 'speaking');
      
      if (voiceEnabled && !isRecording) {
        micBtn.classList.remove('disabled');
      }
    }
    
    // Mic button event listeners - only for push-to-talk mode (not hands-free)
    micBtn.addEventListener('mousedown', () => {
      if (!isHandsFree && voiceEnabled) {
        startRecording();
      }
    });
    micBtn.addEventListener('mouseup', () => {
      if (!isHandsFree && voiceEnabled) {
        stopRecording();
      }
    });
    micBtn.addEventListener('mouseleave', () => {
      if (!isHandsFree && isRecording) {
        stopRecording();
      }
    });
    
    // Touch support for mobile
    micBtn.addEventListener('touchstart', (e) => {
      if (!isHandsFree && voiceEnabled) {
        e.preventDefault();
        startRecording();
      }
    });
    micBtn.addEventListener('touchend', (e) => {
      if (!isHandsFree && voiceEnabled) {
        e.preventDefault();
        stopRecording();
      }
    });
    
    // Voice toggle button
    voiceToggleBtn.addEventListener('click', toggleVoiceMode);

    // ===== MODEL SELECTOR FUNCTIONALITY =====

    let availableModels = {};
    let activeModelId = null;

    // Model selector elements
    const modelSelector = document.getElementById('modelSelector');
    const modelSelectBtn = document.getElementById('modelSelectBtn');
    const modelDropdown = document.getElementById('modelDropdown');
    const activeModelName = document.getElementById('activeModelName');

    // Load available models
    async function loadAvailableModels() {
      try {
        const response = await fetch(`${getApiBase()}/models`);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const data = await response.json();
        availableModels = data.models || {};
        activeModelId = data.active_model;

        updateModelDropdown();
        updateActiveModelDisplay();
      } catch (error) {
        console.error('[MODEL] Failed to load models:', error);
        activeModelName.textContent = 'Error loading models';
      }
    }

    // Update the dropdown with available models
    function updateModelDropdown() {
      if (!modelDropdown) return;

      const modelIds = Object.keys(availableModels);
      if (modelIds.length === 0) {
        modelDropdown.innerHTML = `
          <div class="model-option">
            <div class="model-info">
              <div class="model-name">No models available</div>
              <div class="model-provider">Check configuration</div>
            </div>
          </div>
        `;
        return;
      }

      modelDropdown.innerHTML = modelIds.map(modelId => {
        const model = availableModels[modelId];
        const isActive = modelId === activeModelId;
        return `
          <div class="model-option ${isActive ? 'active' : ''}" data-model="${modelId}">
            <div class="model-info">
              <div class="model-name">${model.display_name}</div>
              <div class="model-provider">${model.provider}</div>
            </div>
            ${isActive ? '<div class="model-status">Active</div>' : ''}
          </div>
        `;
      }).join('');

      // Add event listeners to model options
      document.querySelectorAll('.model-option').forEach(option => {
        option.addEventListener('click', () => {
          const modelId = option.dataset.model;
          if (modelId && modelId !== 'loading') {
            selectModel(modelId);
          }
        });
      });
    }

    // Update the active model display
    function updateActiveModelDisplay() {
      if (!activeModelName) return;

      if (activeModelId && availableModels[activeModelId]) {
        const model = availableModels[activeModelId];
        activeModelName.textContent = model.display_name.split(' ')[0]; // Show first word (e.g., "GPT-4o")
      } else {
        activeModelName.textContent = 'No model';
      }
    }

    // Select a model
    async function selectModel(modelId) {
      if (!modelId || modelId === activeModelId) return;

      try {
        const response = await fetch(`${getApiBase()}/models/active`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ model_id: modelId })
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();
        if (data.success) {
          activeModelId = modelId;
          updateModelDropdown();
          updateActiveModelDisplay();
          closeModelDropdown();

          // Show success message
          showToast(`Model switched to ${availableModels[modelId].display_name}`, 'success');
        } else {
          throw new Error(data.error || 'Failed to switch model');
        }
      } catch (error) {
        console.error('[MODEL] Failed to switch model:', error);
        showToast(`Failed to switch model: ${error.message}`, 'error');
      }
    }

    // Toggle dropdown visibility
    function toggleModelDropdown() {
      if (!modelSelector) return;

      const isOpen = modelSelector.classList.contains('open');
      if (isOpen) {
        closeModelDropdown();
      } else {
        openModelDropdown();
      }
    }

    function openModelDropdown() {
      if (!modelSelector || !modelDropdown) return;
      modelSelector.classList.add('open');
      modelDropdown.classList.add('show');
    }

    function closeModelDropdown() {
      if (!modelSelector || !modelDropdown) return;
      modelSelector.classList.remove('open');
      modelDropdown.classList.remove('show');
    }

    // Event listeners for model selector
    if (modelSelectBtn) {
      modelSelectBtn.addEventListener('click', toggleModelDropdown);
    }

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!modelSelector?.contains(e.target)) {
        closeModelDropdown();
      }
    });

    // Load models on page load
    loadAvailableModels();

    // ===== TOAST NOTIFICATIONS =====

    function showToast(message, type = 'info') {
      // Remove existing toasts
      const existingToasts = document.querySelectorAll('.toast-notification');
      existingToasts.forEach(toast => toast.remove());

      // Create toast element
      const toast = document.createElement('div');
      toast.className = `toast-notification toast-${type}`;
      toast.innerHTML = `
        <div class="toast-content">
          <span class="toast-message">${message}</span>
          <button class="toast-close" onclick="this.parentElement.parentElement.remove()">×</button>
        </div>
      `;

      // Add to page
      document.body.appendChild(toast);

      // Auto-remove after 5 seconds
      setTimeout(() => {
        if (toast.parentElement) {
          toast.remove();
        }
      }, 5000);
    }
    
    // No modal handlers needed - voice mode auto-starts with countdown
    
    // Check voice availability on page load
    checkVoiceAvailability();
    
    // Attach STT provider change listener
    document.getElementById('sttProviderSelect').addEventListener('change', handleSTTProviderChange);
    
    // ===== END VOICE FUNCTIONALITY =====

    // ===== EVALUATION TOGGLE FUNCTIONALITY =====
    
    // Toggle evaluation functionality
    async function toggleEvaluations() {
      const toggle = document.getElementById('evaluationToggle');
      const status = document.getElementById('evaluationStatus');
      const latencySpan = document.getElementById('evaluationLatency');
      
      const enabled = toggle.checked;
      
      try {
        const response = await fetch('/evaluation/toggle', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            session_id: sessionId,
            enabled: enabled
          })
        });
        
        const data = await response.json();
        
        if (data.success) {
          status.textContent = enabled ? 'Enabled' : 'Disabled';
          status.style.color = enabled ? '#4CAF50' : '#666';
          latencySpan.textContent = enabled ? '(+5-7 seconds per response)' : '(Fast mode)';
          
          console.log(`[EVALUATIONS] ${enabled ? 'Enabled' : 'Disabled'} for session ${sessionId}`);
        }
      } catch (error) {
        console.error('Failed to toggle evaluations:', error);
        toggle.checked = !enabled; // Revert on error
      }
    }
    
    // Load evaluation status on page load
    async function loadEvaluationStatus() {
      try {
        const response = await fetch(`/evaluation/status?session_id=${sessionId}`);
        const data = await response.json();
        
        const toggle = document.getElementById('evaluationToggle');
        const status = document.getElementById('evaluationStatus');
        const latencySpan = document.getElementById('evaluationLatency');
        
        if (toggle && status && latencySpan) {
          toggle.checked = data.evaluations_enabled;
          status.textContent = data.evaluations_enabled ? 'Enabled' : 'Disabled';
          status.style.color = data.evaluations_enabled ? '#4CAF50' : '#666';
          
          if (data.evaluations_enabled) {
            latencySpan.textContent = '(+5-7 seconds per response)';
          } else {
            latencySpan.textContent = '(Fast mode)';
          }
        }
      } catch (error) {
        console.error('Failed to load evaluation status:', error);
      }
    }
    
    // Load evaluation status when page loads
    loadEvaluationStatus();
    
    // ===== END EVALUATION TOGGLE FUNCTIONALITY =====

    // Add a function to start a new conversation (clear memory)
    async function startNewConversation() {
      // Starting new chat
      
      // Create new session for new conversation
      const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
      const timestamp = new Date().getTime().toString().slice(-6);
      const randomId = Math.random().toString(36).substr(2, 6);
      sessionId = `cf.conversation.${date}.${timestamp}${randomId}`;
      localStorage.setItem('chatbot_session_id', sessionId);
      messagesDiv.innerHTML = '';
      // Messages cleared
      
      // Reset greeting flag for new conversation
      greetingSent = false;
      
      // Send initial greeting from bot
      sendInitialGreeting();
    }
    
    // Function to send initial greeting message from bot
    // This gets the initial greeting directly from the backend following the system prompt
    async function sendInitialGreeting() {
      // Prevent duplicate greetings
      if (greetingSent) {
        return;
      }
      
      // Check if there are already messages (including bot messages)
      if (messagesDiv.children.length > 0) {
        greetingSent = true;
        return;
      }
      
      // Check if there are any user messages (conversation has started)
      const userMessages = messagesDiv.querySelectorAll('.message.user');
      if (userMessages.length > 0) {
        greetingSent = true;
        return;
      }
      
      greetingSent = true;
      
      const startTime = performance.now();
      console.log('[STEP] Generating Initial Greeting...');
      
      // Show thinking animation
      const botDiv = addMessageHTML("", "bot");
      botDiv.innerHTML = `
        <div class="thinking">
          Thinking
          <span class="thinking-dots">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
      `;
      
      // Force scroll to ensure thinking is visible
      setTimeout(() => scrollToBottom(), 50);
      
      // Start streaming - enable scroll tracking
      isStreaming = true;
      scrollMode = 'auto';
      updateButtonVisibility();
      
      try {
        const response = await fetch(`${getApiBase()}/chat/greeting`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            session_id: sessionId
          })
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        // Keep thinking animation until we get thinking_complete signal
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        let fullResponse = "";
        let lastRenderTime = 0;
        const renderThrottle = 16; // 60fps - re-render every 16ms for smooth streaming
        
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || ""; // Keep incomplete line in buffer
          
          for (const line of lines) {
            if (line.startsWith('data: ')) {
              try {
                const data = JSON.parse(line.slice(6));
                
                if (data.type === 'thinking_complete') {
                  // Clear thinking animation and prepare for streaming
                  botDiv.innerHTML = `<div class="message-content"></div>`;
                } else if (data.type === 'token') {
                  // Add token to response
                  const token = data.token;
                  fullResponse += token;
                  
                  // Throttle rendering to improve performance
                  const now = Date.now();
                  if (now - lastRenderTime > renderThrottle) {
                    // Render markdown and update only the message content
                    const contentDiv = botDiv.querySelector('.message-content');
                    if (contentDiv) {
                      contentDiv.innerHTML = renderMarkdown(fullResponse);
                    } else {
                      // Fallback: create content div only
                      botDiv.innerHTML = `<div class="message-content">${renderMarkdown(fullResponse)}</div>`;
                    }
                    scrollToBottom();
                    lastRenderTime = now;
                  }
                } else if (data.type === 'audio_chunk') {
                  // Streaming TTS audio chunk received
                  console.log('[TTS STREAM] Received audio chunk for:', data.sentence?.substring(0, 50));
                  audioQueue.add(data.audio);
                  receivedStreamingAudio = true; // Mark that we got streaming audio
                } else if (data.type === 'done') {
                  // Final response received
                  fullResponse = data.full_response || fullResponse;
                  
                  // Log timing for greeting generation
                  logTiming('Initial Greeting Generation', startTime);
                  
                  // Check if response is empty
                  if (!fullResponse || fullResponse.trim() === '') {
                    console.error("[ERROR] Empty greeting received!");
                    fullResponse = "Hello! I'm HealthYoda, your medical intake assistant. What brings you in today?";
                  }
                  
                  // Final render with complete response and buttons
                  botDiv.innerHTML = `
                    <div class="message-content">${renderMarkdown(fullResponse)}</div>
                    <div class="feedback-buttons">
                      <button class="copy-button" onclick="copyMessage(this)" title="Copy message">
                        📋
                      </button>
                      <button class="feedback-btn thumbs-up" onclick="submitFeedback(this, 'thumbs_up')" title="Good response">
                        👍
                      </button>
                      <button class="feedback-btn thumbs-down" onclick="submitFeedback(this, 'thumbs_down')" title="Bad response">
                        👎
                      </button>
                      <span class="feedback-text"></span>
                    </div>
                  `;
                  
                  scrollToBottom();
                  isStreaming = false;
                } else if (data.type === 'error') {
                  throw new Error(data.error || 'Unknown error');
                }
              } catch (parseError) {
                console.error('[ERROR] Error parsing greeting stream data:', parseError);
              }
            }
          }
        }
      } catch (error) {
        logTiming('Initial Greeting Generation (FAILED)', startTime);
        console.error('[ERROR] Error getting greeting:', error);
        // Remove thinking animation and reset flag
        if (botDiv && botDiv.parentNode) {
          botDiv.remove();
        }
        greetingSent = false;
        isStreaming = false;
        // Fallback: send a message to trigger the bot
        await sendMessageText("start");
      }
    }

    // Variables for undo functionality
    let chatBackup = null;
    let undoTimeout = null;
    let isUndoMode = false;

    // Handle new chat button click
    async function handleNewChat() {
      const button = document.getElementById('newChatBtn');
      
      if (!isUndoMode) {
        // Store current chat before clearing
        chatBackup = {
          messages: Array.from(messagesDiv.children).map(msg => ({
            className: msg.className,
            innerHTML: msg.innerHTML
          })),
          sessionId: sessionId
        };
        
        // Clear the messages display
        // Clearing messages for undo
        messagesDiv.innerHTML = '';
        
        // Change button to undo mode
        button.innerHTML = '<span><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M2.6687 11.333V8.66699C2.6687 7.74455 2.66841 7.01205 2.71655 6.42285C2.76533 5.82612 2.86699 5.31731 3.10425 4.85156L3.25854 4.57617C3.64272 3.94975 4.19392 3.43995 4.85229 3.10449L5.02905 3.02149C5.44666 2.84233 5.90133 2.75849 6.42358 2.71582C7.01272 2.66769 7.74445 2.66797 8.66675 2.66797H9.16675C9.53393 2.66797 9.83165 2.96586 9.83179 3.33301C9.83179 3.70028 9.53402 3.99805 9.16675 3.99805H8.66675C7.7226 3.99805 7.05438 3.99834 6.53198 4.04102C6.14611 4.07254 5.87277 4.12568 5.65601 4.20313L5.45581 4.28906C5.01645 4.51293 4.64872 4.85345 4.39233 5.27149L4.28979 5.45508C4.16388 5.7022 4.08381 6.01663 4.04175 6.53125C3.99906 7.05373 3.99878 7.7226 3.99878 8.66699V11.333C3.99878 12.2774 3.99906 12.9463 4.04175 13.4688C4.08381 13.9833 4.16389 14.2978 4.28979 14.5449L4.39233 14.7285C4.64871 15.1465 5.01648 15.4871 5.45581 15.7109L5.65601 15.7969C5.87276 15.8743 6.14614 15.9265 6.53198 15.958C7.05439 16.0007 7.72256 16.002 8.66675 16.002H11.3337C12.2779 16.002 12.9461 16.0007 13.4685 15.958C13.9829 15.916 14.2976 15.8367 14.5447 15.7109L14.7292 15.6074C15.147 15.3511 15.4879 14.9841 15.7117 14.5449L15.7976 14.3447C15.8751 14.128 15.9272 13.8546 15.9587 13.4688C16.0014 12.9463 16.0017 12.2774 16.0017 11.333V10.833C16.0018 10.466 16.2997 10.1681 16.6667 10.168C17.0339 10.168 17.3316 10.4659 17.3318 10.833V11.333C17.3318 12.2555 17.3331 12.9879 17.2849 13.5771C17.2422 14.0993 17.1584 14.5541 16.9792 14.9717L16.8962 15.1484C16.5609 15.8066 16.0507 16.3571 15.4246 16.7412L15.1492 16.8955C14.6833 17.1329 14.1739 17.2354 13.5769 17.2842C12.9878 17.3323 12.256 17.332 11.3337 17.332H8.66675C7.74446 17.332 7.01271 17.3323 6.42358 17.2842C5.90135 17.2415 5.44665 17.1577 5.02905 16.9785L4.85229 16.8955C4.19396 16.5601 3.64271 16.0502 3.25854 15.4238L3.10425 15.1484C2.86697 14.6827 2.76534 14.1739 2.71655 13.5771C2.66841 12.9879 2.6687 12.2555 2.6687 11.333ZM13.4646 3.11328C14.4201 2.334 15.8288 2.38969 16.7195 3.28027L16.8865 3.46485C17.6141 4.35685 17.6143 5.64423 16.8865 6.53613L16.7195 6.7207L11.6726 11.7686C11.1373 12.3039 10.4624 12.6746 9.72827 12.8408L9.41089 12.8994L7.59351 13.1582C7.38637 13.1877 7.17701 13.1187 7.02905 12.9707C6.88112 12.8227 6.81199 12.6134 6.84155 12.4063L7.10132 10.5898L7.15991 10.2715C7.3262 9.53749 7.69692 8.86241 8.23218 8.32715L13.2791 3.28027L13.4646 3.11328ZM15.7791 4.2207C15.3753 3.81702 14.7366 3.79124 14.3035 4.14453L14.2195 4.2207L9.17261 9.26856C8.81541 9.62578 8.56774 10.0756 8.45679 10.5654L8.41772 10.7773L8.28296 11.7158L9.22241 11.582L9.43433 11.543C9.92426 11.432 10.3749 11.1844 10.7322 10.8271L15.7791 5.78027L15.8552 5.69629C16.185 5.29194 16.1852 4.708 15.8552 4.30371L15.7791 4.2207Z"></path></svg></span><span>Undo</span><div class="countdown-container"><div class="countdown-circle" id="countdownCircle"></div></div>';
        button.classList.add('undo-mode');
        isUndoMode = true;
        
        // Initialize countdown circle
        initializeCountdownCircle();
        
        // Start countdown - this will call permanentlyDeleteChat after 3 seconds
        // The greeting will be sent AFTER the timer ends (in permanentlyDeleteChat)
        startUndoCountdown();
      } else {
        // Restore chat
        restoreChat();
      }
    }

    // Initialize countdown circle
    function initializeCountdownCircle() {
      const circle = document.getElementById('countdownCircle');
      const radius = 10; // radius of the circle (increased from 8)
      const circumference = 2 * Math.PI * radius;
      
      // Create SVG circle - start with full circle (offset = 0)
      circle.innerHTML = `
        <svg width="24" height="24">
          <circle class="progress-ring progress-ring-bg" cx="12" cy="12" r="${radius}"></circle>
          <circle class="progress-ring progress-ring-fill" cx="12" cy="12" r="${radius}" 
                  stroke-dasharray="${circumference}" 
                  stroke-dashoffset="0"></circle>
        </svg>
        <span class="countdown-text" id="countdownText">3</span>
      `;
      
      // Store circumference for animation
      circle.dataset.circumference = circumference;
    }

    // Start undo countdown
    function startUndoCountdown() {
      const textElement = document.getElementById('countdownText');
      const circle = document.getElementById('countdownCircle');
      const circumference = parseFloat(circle.dataset.circumference);
      
      const startTime = Date.now();
      const duration = 3000; // 3 seconds in milliseconds
      
      const updateCountdown = () => {
        const elapsed = Date.now() - startTime;
        const remaining = Math.max(0, duration - elapsed);
        const countdown = Math.ceil(remaining / 1000);
        
        // Update text (always white)
        textElement.textContent = countdown;
        textElement.style.color = 'white';
        
        // Update circle progress - smooth animation
        const progress = remaining / duration; // This goes from 1.0 to 0.0
        const offset = circumference - (progress * circumference);
        const fillCircle = circle.querySelector('.progress-ring-fill');
        fillCircle.style.strokeDashoffset = offset;
        
        // Keep circle white always
        fillCircle.style.stroke = '#fff';
        
        if (remaining > 0) {
          undoTimeout = requestAnimationFrame(updateCountdown);
        } else {
          // Time's up - permanently delete chat
          permanentlyDeleteChat();
        }
      };
      
      updateCountdown();
    }

    // Restore chat from backup
    function restoreChat() {
      if (chatBackup) {
        // Restore messages
        messagesDiv.innerHTML = '';
        chatBackup.messages.forEach(msgData => {
          const msgDiv = document.createElement('div');
          msgDiv.className = msgData.className;
          msgDiv.innerHTML = msgData.innerHTML;
          messagesDiv.appendChild(msgDiv);
        });
        
        // Add copy buttons to any bot messages that don't have them
        const botMessages = messagesDiv.querySelectorAll('.message.bot');
        botMessages.forEach(msgDiv => {
          if (!msgDiv.querySelector('.copy-button')) {
            const textContent = msgDiv.textContent || msgDiv.innerText || '';
            if (textContent.trim()) {
              msgDiv.innerHTML = `
                <div class="message-content">${msgDiv.innerHTML}</div>
                <button class="copy-button" onclick="copyMessage(this)" title="Copy message">
                  📋
                </button>
              `;
            }
          }
        });
        
        // Restore session
        sessionId = chatBackup.sessionId;
        localStorage.setItem('chatbot_session_id', sessionId);
        
        // Reset greeting flag since we're restoring old chat
        greetingSent = true; // Set to true since we have messages
        
        // Scroll to bottom after restoring messages
        scrollToBottom();
        
        // Clear backup
        chatBackup = null;
      }
      
      // Reset button
      resetNewChatButton();
    }

    // Permanently delete chat
    async function permanentlyDeleteChat() {
      // Create new session for new conversation
      const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
      const timestamp = new Date().getTime().toString().slice(-6);
      const randomId = Math.random().toString(36).substr(2, 6);
      sessionId = `cf.conversation.${date}.${timestamp}${randomId}`;
      localStorage.setItem('chatbot_session_id', sessionId);
      
      // Clear messages display
      messagesDiv.innerHTML = '';
      
      // Clear backup
      chatBackup = null;
      
      // Reset button
      resetNewChatButton();
      
      // Reset greeting flag for new conversation
      greetingSent = false;
      
      // Reset voice mode state for new chat
      voiceEnabled = false;
      isHandsFree = false;
      voiceToggleBtn.classList.remove('active');
      voiceToggleBtn.querySelector('span').textContent = 'Voice Off';
      micBtn.classList.add('disabled');
      micBtn.title = 'Push to talk';
      stopRecording();
      stopSpeaking();
      
      // Show voice warning modal for new chat
      // The greeting will be sent after user chooses an option in the modal
      showVoiceCountdown();
    }

    // Reset new chat button to normal state
    function resetNewChatButton() {
      const button = document.getElementById('newChatBtn');
      button.innerHTML = '<span><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M2.6687 11.333V8.66699C2.6687 7.74455 2.66841 7.01205 2.71655 6.42285C2.76533 5.82612 2.86699 5.31731 3.10425 4.85156L3.25854 4.57617C3.64272 3.94975 4.19392 3.43995 4.85229 3.10449L5.02905 3.02149C5.44666 2.84233 5.90133 2.75849 6.42358 2.71582C7.01272 2.66769 7.74445 2.66797 8.66675 2.66797H9.16675C9.53393 2.66797 9.83165 2.96586 9.83179 3.33301C9.83179 3.70028 9.53402 3.99805 9.16675 3.99805H8.66675C7.7226 3.99805 7.05438 3.99834 6.53198 4.04102C6.14611 4.07254 5.87277 4.12568 5.65601 4.20313L5.45581 4.28906C5.01645 4.51293 4.64872 4.85345 4.39233 5.27149L4.28979 5.45508C4.16388 5.7022 4.08381 6.01663 4.04175 6.53125C3.99906 7.05373 3.99878 7.7226 3.99878 8.66699V11.333C3.99878 12.2774 3.99906 12.9463 4.04175 13.4688C4.08381 13.9833 4.16389 14.2978 4.28979 14.5449L4.39233 14.7285C4.64871 15.1465 5.01648 15.4871 5.45581 15.7109L5.65601 15.7969C5.87276 15.8743 6.14614 15.9265 6.53198 15.958C7.05439 16.0007 7.72256 16.002 8.66675 16.002H11.3337C12.2779 16.002 12.9461 16.0007 13.4685 15.958C13.9829 15.916 14.2976 15.8367 14.5447 15.7109L14.7292 15.6074C15.147 15.3511 15.4879 14.9841 15.7117 14.5449L15.7976 14.3447C15.8751 14.128 15.9272 13.8546 15.9587 13.4688C16.0014 12.9463 16.0017 12.2774 16.0017 11.333V10.833C16.0018 10.466 16.2997 10.1681 16.6667 10.168C17.0339 10.168 17.3316 10.4659 17.3318 10.833V11.333C17.3318 12.2555 17.3331 12.9879 17.2849 13.5771C17.2422 14.0993 17.1584 14.5541 16.9792 14.9717L16.8962 15.1484C16.5609 15.8066 16.0507 16.3571 15.4246 16.7412L15.1492 16.8955C14.6833 17.1329 14.1739 17.2354 13.5769 17.2842C12.9878 17.3323 12.256 17.332 11.3337 17.332H8.66675C7.74446 17.332 7.01271 17.3323 6.42358 17.2842C5.90135 17.2415 5.44665 17.1577 5.02905 16.9785L4.85229 16.8955C4.19396 16.5601 3.64271 16.0502 3.25854 15.4238L3.10425 15.1484C2.86697 14.6827 2.76534 14.1739 2.71655 13.5771C2.66841 12.9879 2.6687 12.2555 2.6687 11.333ZM13.4646 3.11328C14.4201 2.334 15.8288 2.38969 16.7195 3.28027L16.8865 3.46485C17.6141 4.35685 17.6143 5.64423 16.8865 6.53613L16.7195 6.7207L11.6726 11.7686C11.1373 12.3039 10.4624 12.6746 9.72827 12.8408L9.41089 12.8994L7.59351 13.1582C7.38637 13.1877 7.17701 13.1187 7.02905 12.9707C6.88112 12.8227 6.81199 12.6134 6.84155 12.4063L7.10132 10.5898L7.15991 10.2715C7.3262 9.53749 7.69692 8.86241 8.23218 8.32715L13.2791 3.28027L13.4646 3.11328ZM15.7791 4.2207C15.3753 3.81702 14.7366 3.79124 14.3035 4.14453L14.2195 4.2207L9.17261 9.26856C8.81541 9.62578 8.56774 10.0756 8.45679 10.5654L8.41772 10.7773L8.28296 11.7158L9.22241 11.582L9.43433 11.543C9.92426 11.432 10.3749 11.1844 10.7322 10.8271L15.7791 5.78027L15.8552 5.69629C16.185 5.29194 16.1852 4.708 15.8552 4.30371L15.7791 4.2207Z"></path></svg></span><span>New Chat</span>';
      button.classList.remove('undo-mode');
      isUndoMode = false;
      
      if (undoTimeout) {
        cancelAnimationFrame(undoTimeout);
        undoTimeout = null;
      }
    }

    // Double-click to start new conversation removed to prevent accidental chat clearing

    // Polyfill for POST EventSource
    class EventSourcePolyfill {
      constructor(url, options) {
        const { method, headers, body } = options;
        this._url = url;
        this._method = method || "GET";
        this._headers = headers || {};
        this._body = body || null;
        this.onmessage = null;
        this.onerror = null;
        this._start();
      }

      async _start() {
        const response = await fetch(this._url, {
          method: this._method,
          headers: this._headers,
          body: this._body,
        });
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });
          const parts = buffer.split("\n\n");
          buffer = parts.pop();
          for (const part of parts) {
            if (part.startsWith("data: ")) {
              const data = part.replace("data: ", "");
              if (this.onmessage) this.onmessage({ data });
            }
          }
        }
      }

      close() {}
    }

    // Simplified user info (no authentication)
    function updateUserInfo() {
      const userName = document.getElementById('userName');
      const userAvatar = document.getElementById('userAvatar');
      const userEmail = document.getElementById('userEmail');
      
      userName.textContent = 'User';
      userAvatar.textContent = 'U';
      userEmail.textContent = 'HealthYoda User';
    }

    // Handle dropdown toggle
    // Removed - User menu functions no longer needed
    /*
    function toggleDropdown() {
      const dropdown = document.getElementById('userDropdown');
      dropdown.classList.toggle('show');
    }

    // Close dropdown when clicking outside
    function closeDropdown(event) {
      const userMenu = document.getElementById('userMenu');
      const dropdown = document.getElementById('userDropdown');
      
      if (!userMenu.contains(event.target)) {
        dropdown.classList.remove('show');
      }
    }

    // Handle logout (simplified - just clear local state)
    function handleLogout() {
      // Clear session
      localStorage.removeItem('chatbot_session_id');
      messagesDiv.innerHTML = '';
      
      // Create new session
      const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
      const timestamp = new Date().getTime().toString().slice(-6);
      const randomId = Math.random().toString(36).substr(2, 6);
      sessionId = `cf.conversation.${date}.${timestamp}${randomId}`;
      localStorage.setItem('chatbot_session_id', sessionId);
      
      // Session cleared
    }
    */

    // OLD AUTH CODE REMOVED - Handle OAuth callback
    function handleOAuthCallback_DELETED() {
      const urlParams = new URLSearchParams(window.location.search);
      const code = urlParams.get('code');
      const error = urlParams.get('error');

      if (error) {
        alert('Microsoft login failed: ' + error);
        return;
      }

      if (code) {
        exchangeCodeForToken(code);
      }
    }

    // Exchange authorization code for access token
    async function exchangeCodeForToken(code) {
      // Get code verifier from session storage
      const codeVerifier = sessionStorage.getItem('code_verifier');
      
      if (!codeVerifier) {
        /*alert('Login failed: Code verifier not found');*/
        window.location.href = "login.html";
        return;
      }
      
      try {
        const requestBody = {
          code: code,
          redirect_uri: window.location.origin + "/index.html",
          code_verifier: codeVerifier
        };
        
        const response = await fetch(`${getApiBase()}/auth/microsoft/callback`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestBody)
        });

        if (response.ok) {
          const data = await response.json();
          // User data received
          
          // Clear code verifier from session storage
          sessionStorage.removeItem('code_verifier');
          
          const user = {
            id: data.user_id,
            name: data.name,
            email: data.email,
            access_token: data.access_token,
            refresh_token: data.refresh_token
          };
          
          // User object created
          
          localStorage.setItem('user', JSON.stringify(user));
          
          // Clear URL parameters
          window.history.replaceState({}, document.title, window.location.pathname);
          
          // Initialize with new user
          currentUser = user;
          updateUserInfo(user);
          
          // Only load history if user.id is valid
          if (user.id) {
            loadUserChatHistory(user.id).catch(error => {
              console.error('[ERROR] Failed to load history:', error);
            });
          } else {
          }
          
          hideLoadingIndicator();
        } else {
          const errorText = await response.text();
          try {
            const errorJson = JSON.parse(errorText);
            if (errorJson.error === "Access denied") {
              alert('Access Denied: ' + errorJson.message);
            } else {
              alert('Login failed: ' + (errorJson.error || errorText || 'Unknown error'));
            }
          } catch (e) {
            alert('Login failed: ' + (errorText || 'Unknown error'));
          }
          hideLoadingIndicator();
          window.location.href = "login.html";
        }
        } catch (error) {
          hideLoadingIndicator();
          alert('Login failed: ' + error.message);
          window.location.href = "login.html";
        }
    }

    // Initialize authentication
    function initAuth() {
      // Check for OAuth callback first
      const urlParams = new URLSearchParams(window.location.search);
      const code = urlParams.get('code');
      
      if (code) {
        // We have an OAuth callback, handle it first
        showLoadingIndicator("Authenticating...");
        handleOAuthCallback();
        return; // Don't check for existing user, let the callback handle it
      }
      
      // Check if user is logged in (only if no OAuth callback)
      const user = JSON.parse(localStorage.getItem('user') || 'null');
      
      // User retrieved from localStorage
      
      if (!user || !user.access_token) {
        // No user found, redirecting to login
        window.location.href = "login.html";
        return;
      }

      // Verify token is still valid AND check domain
      showLoadingIndicator("Verifying access...");
      verifyToken(user.access_token).then(result => {
        if (result.isValid) {
          currentUser = user;
          updateUserInfo(user);
          // User authenticated, loading history
          
          // Always load history, even if it fails (but only if user.id exists)
          if (user.id) {
            loadUserChatHistory(user.id).catch(error => {
              console.error('[ERROR] Failed to load history, but continuing:', error);
              // If history loading fails and no messages, show modal
              setTimeout(() => {
                if (messagesDiv.children.length === 0 && !greetingSent) {
                  showVoiceCountdown();
                }
              }, 500);
            }).finally(() => {
              hideLoadingIndicator();
              // Double-check after history load completes - if still no messages, show modal
              setTimeout(() => {
                if (messagesDiv.children.length === 0 && !greetingSent) {
                  showVoiceCountdown();
                }
              }, 300);
            });
          } else {
            hideLoadingIndicator();
            // No user ID, show modal
            setTimeout(() => {
              if (messagesDiv.children.length === 0 && !greetingSent) {
                showVoiceCountdown();
              }
            }, 500);
          }
        } else {
          // Handle different failure reasons
          hideLoadingIndicator();
          
          // Clear invalid user data
          localStorage.removeItem('user');
          currentUser = null;
          
          // Redirect to login with appropriate error parameter
          if (result.reason === 'unauthorized_domain') {
            window.location.href = `login.html?error=unauthorized_domain&email=${encodeURIComponent(result.email || 'Unknown')}`;
          } else if (result.reason === 'invalid_token') {
            window.location.href = "login.html?error=session_expired";
          } else {
            // Token verification failed
            window.location.href = "login.html?error=verification_failed";
          }
        }
      }).catch(error => {
        console.error('[ERROR] Token verification failed:', error);
        hideLoadingIndicator();
        // Don't allow app access if verification fails
        localStorage.removeItem('user');
        currentUser = null;
        window.location.href = "login.html?error=verification_failed";
      });
    }

    // Verify Microsoft access token
    async function verifyToken(accessToken) {
      try {
        const response = await fetch('https://graph.microsoft.com/v1.0/me', {
          headers: {
            'Authorization': `Bearer ${accessToken}`
          }
        });
        
        if (!response.ok) {
          return { isValid: false, reason: 'invalid_token' };
        }
        
        const userInfo = await response.json();
        const userEmail = userInfo.mail || userInfo.userPrincipalName || '';
        
        return { isValid: true, email: userEmail };
      } catch (error) {
        console.error('[AUTH] Token verification failed:', error);
        return { isValid: false, reason: 'verification_failed' };
      }
    }

    // Update user info in header
    // Update user info in UI - DISABLED (user menu removed)
    function updateUserInfo(user) {
      // Removed - user menu no longer exists
      return;
    }

    // Handle dropdown toggle - DISABLED (user menu removed)
    function toggleDropdown() {
      // Removed - user menu no longer exists
      return;
    }

    // Close dropdown when clicking outside - DISABLED (user menu removed)
    function closeDropdown(event) {
      // Removed - user menu no longer exists
      return;
    }

    // Load user's chat history
    async function loadUserChatHistory(userId) {
      try {
        // Loading chat history
        
        // Reset greeting flag when loading history (will be set if history is empty)
        greetingSent = false;
        
        // Check if userId is valid
        if (!userId || userId === 'undefined' || userId === 'null') {
          console.error('[HISTORY] Invalid user ID:', userId);
          return;
        }
        
        // Get current user for auth token
        const currentUser = JSON.parse(localStorage.getItem('user') || 'null');
        if (!currentUser || !currentUser.access_token) {
          console.error('[HISTORY] User not authenticated');
          return;
        }
        
        const response = await fetch(`${getApiBase()}/chat/history/${userId}`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${currentUser.access_token}`
          }
        });
        
          if (response.ok) {
          const data = await response.json();
          const history = data.history || [];
          // History loaded
          
          // Only clear if we have history to show
          if (history.length > 0) {
            // Clear existing messages
            messagesDiv.innerHTML = '';
            
            // Load chat history
            for (const message of history) {
              const sender = message.role === 'user' ? 'user' : 'bot';
              if (sender === 'bot') {
                // Render markdown for bot messages with copy button and feedback buttons
                // Note: Historical messages won't have trace_id, so feedback won't work for them
                addMessageHTML(renderMarkdown(message.content), sender, null);
              } else {
                // Add user messages with edit button
                addMessage(message.content, sender);
              }
            }
            
            // History displayed
            // Scroll to bottom
            scrollToBottom();
          } else {
            // No history to load - show modal
            if (!greetingSent) {
              showVoiceCountdown();
            }
          }
        } else {
          console.error('[HISTORY] Failed to load, status:', response.status);
          const errorText = await response.text();
          console.error('[HISTORY] Error details:', errorText);
        }
      } catch (error) {
        console.error('[HISTORY] Failed to load chat history:', error);
        console.error('[HISTORY] Error details:', error.message, error.stack);
        // Continue with empty chat if loading fails
        // Show modal if no messages are displayed
        if (messagesDiv.children.length === 0 && !greetingSent) {
          showVoiceCountdown();
        }
      }
    }

    // Handle logout
    function handleLogout() {
      try {
        
  



        // Clear user data from localStorage
        localStorage.removeItem('user');
        currentUser = null;
        
        // Redirect to login page
        window.location.href = "login.html";
      } catch (error) {
        console.error('Logout failed:', error);
        alert('Logout failed: ' + error.message);
      }
    }

    // Initialize when page loads (no authentication)
    // updateUserInfo(); // DISABLED - user menu removed

    // Event listeners
    document.getElementById('newChatBtn').addEventListener('click', handleNewChat);
    
    // Settings button handler
    document.getElementById('settingsBtn').addEventListener('click', function() {
      const settingsPanel = document.getElementById('settingsPanel');
      const settingsBtn = document.getElementById('settingsBtn');
      
      if (settingsPanel.classList.contains('open')) {
        settingsPanel.classList.remove('open');
        settingsBtn.classList.remove('active');
      } else {
        settingsPanel.classList.add('open');
        settingsBtn.classList.add('active');
      }
    });
    
    // Close settings panel when clicking outside
    document.addEventListener('click', function(event) {
      const settingsPanel = document.getElementById('settingsPanel');
      const settingsBtn = document.getElementById('settingsBtn');
      
      if (!settingsPanel.contains(event.target) && !settingsBtn.contains(event.target)) {
        if (settingsPanel.classList.contains('open')) {
          settingsPanel.classList.remove('open');
          settingsBtn.classList.remove('active');
        }
      }
    });
    
    // Removed old user menu handlers
    // document.getElementById('userMenu').addEventListener('click', toggleDropdown);
    // document.getElementById('logoutBtn').addEventListener('click', handleLogout);
    // document.addEventListener('click', closeDropdown);
    
    // Show voice warning modal by default on page load
    // Wait a bit to ensure DOM is ready and history is loaded
    setTimeout(() => {
      // Only show modal if there are no messages (new session or empty chat)
      if (messagesDiv.children.length === 0) {
        // Show the hands-free voice mode modal by default
        showVoiceCountdown();
      }
    }, 1500); // Wait 1.5 seconds for history to potentially load
  </script>

  <!-- Voice mode countdown -->
  <div id="voiceCountdownModal" class="modal">
    <div class="modal-content">
      <h3>🎤 Starting Voice Agent</h3>
      <p id="countdownText">Voice mode will start in <span id="countdownNumber">3</span> seconds...</p>
    </div>
  </div>
</body>
</html>
