<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
  
  <title>HealthYoda - Your Health Assistant</title>
  <meta name="description" content="Ask HealthYoda for health-related queries and get instant, intelligent responses. Your AI-powered health assistant.">
  <meta name="keywords" content="AI Chat Agent, AI assistant, health chatbot, HealthYoda, health assistant">
  <meta name="author" content="HealthYoda">
  <meta name="google-site-verification" content="PhjlsaI1LwJ0elVNYMvimmGx_a_PXGb6XQZZSRWsm10" />
  <meta name="robots" content="noindex, follow">
  
  <!-- Open Graph -->
  <meta property="og:title" content="HealthYoda - Your Health Assistant">
  <meta property="og:description" content="Ask HealthYoda for health-related queries and get instant, intelligent responses. Your AI-powered health assistant.">
  <meta property="og:type" content="website">
  
  <!-- Twitter Cards -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="HealthYoda - Your Health Assistant">
  <meta name="twitter:description" content="Ask HealthYoda for health-related queries and get instant, intelligent responses. Your AI-powered health assistant.">
  
  <!-- Structured Data (Schema.org) -->
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "HealthYoda",
      "description": "HealthYoda offers instant, AI-driven health guidance. Get expert health insights and information.",
      "applicationCategory": "HealthApplication",
      "operatingSystem": "Web"
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    /* Loading animation */
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    html {
      scrollbar-gutter: stable;
    }

    body { 
      font-family: Arial, sans-serif; 
      background: white; 
      margin: 0; 
      padding: 0;
      min-height: 100vh;
      scroll-behavior: smooth;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: white;
      width: 100%;
      padding: 10px 20px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
    }

    header img {
      height: 40px;
    }

    .header-controls {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .voice-toggle-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: #f8f9fa;
      color: #495057;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s ease;
      font-family: inherit;
      min-width: 100px;
    }

    .voice-toggle-btn:hover {
      background: #e9ecef;
      border-color: #adb5bd;
      color: #212529;
    }

    .voice-toggle-btn.active {
      background: #28a745;
      color: white;
      border-color: #28a745;
    }

    .voice-toggle-btn.active:hover {
      background: #218838;
      border-color: #1e7e34;
    }

    .new-chat-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: #f8f9fa;
      color: #495057;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s ease;
      font-family: inherit;
      min-width: 100px;
    }

    .new-chat-btn:hover {
      background: #e9ecef;
      border-color: #adb5bd;
      color: #212529;
    }

    .new-chat-btn:active {
      background: #dee2e6;
      transform: translateY(1px);
    }

    .new-chat-btn.undo-mode {
      background: #dc3545;
      color: white;
      border-color: #dc3545;
      min-width: 100px;
    }

    .new-chat-btn.undo-mode:hover {
      background: #c82333;
      border-color: #bd2130;
    }

    /* Model selector dropdown */
    .model-selector {
      position: relative;
      display: inline-block;
    }

    .model-select-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      background: #f8f9fa;
      color: #495057;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s ease;
      font-family: inherit;
      min-width: 140px;
    }

    .model-select-btn:hover {
      background: #e9ecef;
      border-color: #adb5bd;
      color: #212529;
    }

    .model-dropdown-arrow {
      font-size: 12px;
      transition: transform 0.2s ease;
    }

    .model-selector.open .model-dropdown-arrow {
      transform: rotate(180deg);
    }

    .model-dropdown {
      position: absolute;
      top: 100%;
      right: 0;
      background: white;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      min-width: 200px;
      max-height: 300px;
      overflow-y: auto;
      z-index: 1001;
      display: none;
      margin-top: 4px;
    }

    .model-dropdown.show {
      display: block;
    }

    .model-option {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      cursor: pointer;
      border-bottom: 1px solid #f8f9fa;
      transition: background-color 0.2s ease;
    }

    .model-option:last-child {
      border-bottom: none;
    }

    .model-option:hover {
      background: #f8f9fa;
    }

    .model-option.active {
      background: #e3f2fd;
      color: #1976d2;
      font-weight: 500;
    }

    .model-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .model-name {
      font-size: 14px;
      font-weight: 500;
    }

    .model-provider {
      font-size: 12px;
      color: #6c757d;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .model-status {
      font-size: 12px;
      color: #28a745;
      font-weight: 500;
    }

    /* Toast notifications */
    .toast-notification {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      min-width: 300px;
      max-width: 500px;
      padding: 0;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      animation: toastSlideIn 0.3s ease-out;
    }

    .toast-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: white;
      border-radius: 8px;
      border-left: 4px solid #007bff;
    }

    .toast-success .toast-content {
      border-left-color: #28a745;
    }

    .toast-error .toast-content {
      border-left-color: #dc3545;
    }

    .toast-warning .toast-content {
      border-left-color: #ffc107;
    }

    .toast-info .toast-content {
      border-left-color: #17a2b8;
    }

    .toast-message {
      flex: 1;
      font-size: 14px;
      color: #333;
    }

    .toast-close {
      background: none;
      border: none;
      font-size: 20px;
      color: #999;
      cursor: pointer;
      padding: 0;
      margin-left: 12px;
      line-height: 1;
    }

    .toast-close:hover {
      color: #666;
    }

    @keyframes toastSlideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .countdown-container {
      position: relative;
      margin-left: 4px;
      width: 24px;
      height: 20px;
    }

    .countdown-circle {
      width: 24px;
      height: 24px;
      position: absolute;
      top: -2px;
      left: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .countdown-circle svg {
      width: 24px;
      height: 24px;
      transform: rotate(-90deg);
      position: absolute;
      top: 0;
      left: 0;
    }

    .countdown-circle .progress-ring {
      fill: none;
      stroke-width: 2;
    }

    .countdown-circle .progress-ring-bg {
      stroke: rgba(255, 255, 255, 0.4);
    }

    .countdown-circle .progress-ring-fill {
      stroke: #fff;
      stroke-linecap: round;
      transition: stroke-dasharray 0.1s linear;
    }

    .countdown-text {
      font-size: 11px;
      font-weight: bold;
      color: white;
      position: absolute;
      z-index: 2;
      text-align: center;
      line-height: 1;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .user-menu {
      position: relative;
      display: flex;
      align-items: center;
      cursor: pointer;
      padding: 8px 12px;
      border-radius: 20px;
      transition: background-color 0.3s ease;
    }

    .user-menu:hover {
      background-color: #f5f5f5;
    }

    .user-info {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .user-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background-color: #0129ac;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 14px;
    }

    .user-name {
      font-size: 14px;
      font-weight: 500;
      color: #333;
    }

    .dropdown-arrow {
      width: 0;
      height: 0;
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-top: 4px solid #666;
      margin-left: 4px;
    }

    .user-dropdown {
      position: absolute;
      top: 100%;
      right: 20px;
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      min-width: 200px;
      z-index: 1001;
      display: none;
      margin-top: 5px;
    }

    .user-dropdown.show {
      display: block;
    }

    .dropdown-item {
      padding: 12px 16px;
      cursor: pointer;
      border-bottom: 1px solid #f0f0f0;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: background-color 0.2s ease;
    }

    .dropdown-item:last-child {
      border-bottom: none;
    }

    .dropdown-item:hover {
      background-color: #f5f5f5;
    }

    .dropdown-item.logout {
      color: #d32f2f;
    }

    .dropdown-item.logout:hover {
      background-color: #ffebee;
    }

    .main-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 80px; /* Space for fixed header */
      min-height: calc(100vh - 80px); /* Ensure content takes full height */
    }

    #messages {
      width: 60%;
      padding: 20px 10px 20px 10px;
      margin-bottom: 50px; /* Space for fixed footer */
      display: flex;
      flex-direction: column;
    }

    .message { 
      margin: 8px 0; 
      padding: 10px 15px; 
      border-radius: 20px; 
      width: fit-content; 
      max-width: 70%;
      word-wrap: break-word;
    }

    .user { 
      background: #e1ecff; 
      color: black; 
      margin-left: auto; 
      text-align: left;
    }
    
    .user-message-wrapper {
      display: inline-flex;
      flex-direction: column;
      align-items: flex-end;
      margin: 8px 0;
      margin-left: auto;
      max-width: 70%;
    }
    
    .user-message-wrapper.editing {
      max-width: 70%;
    }
    
    .user-message-wrapper .message.user {
      margin: 0;
      width: auto;
      max-width: none;
    }

    .bot { 
      background: white; 
      color: black; 
      margin-right: auto; 
      text-align: left; 
      position: relative;
      padding-bottom: 35px; /* Extra space for feedback buttons */
    }

    /* Thinking animation */
    .thinking {
      display: flex;
      align-items: center;
      gap: 8px;
      font-style: italic;
      color: #666;
    }

    .thinking-dots {
      display: inline-flex;
      gap: 4px;
    }

    .thinking-dots span {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background-color: #666;
      animation: thinking-bounce 1.4s infinite ease-in-out both;
    }

    .thinking-dots span:nth-child(1) {
      animation-delay: -0.32s;
    }

    .thinking-dots span:nth-child(2) {
      animation-delay: -0.16s;
    }

    .thinking-dots span:nth-child(3) {
      animation-delay: 0s;
    }

    @keyframes thinking-bounce {
      0%, 80%, 100% {
        transform: scale(0);
        opacity: 0.5;
      }
      40% {
        transform: scale(1);
        opacity: 1;
      }
    }

    /* Markdown styling for bot messages */
    .bot h1, .bot h2, .bot h3, .bot h4, .bot h5, .bot h6 {
      margin: 10px 0 5px 0;
      font-weight: bold;
    }
    
    .bot h1 { font-size: 1.5em; }
    .bot h2 { font-size: 1.3em; }
    .bot h3 { font-size: 1.1em; }
    
    .bot ul, .bot ol {
      margin: 10px 0;
      padding-left: 20px;
    }
    
    .bot li {
      margin: 5px 0;
    }
    
    .bot strong {
      font-weight: bold;
    }
    
    .bot em {
      font-style: italic;
    }
    
    .bot code {
      background-color: #f4f4f4;
      padding: 2px 4px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
    }
    
    .bot pre {
      background-color: #f4f4f4;
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto;
      margin: 10px 0;
    }
    
    .bot pre code {
      background: none;
      padding: 0;
    }
    
    .bot blockquote {
      border-left: 4px solid #ddd;
      margin: 10px 0;
      padding-left: 15px;
      color: #666;
    }
    
    .bot a {
      color: #0066cc;
      text-decoration: underline;
    }
    
    .bot a:hover {
      color: #004499;
    }

    /* Copy button styles - ChatGPT style */
    .copy-button {
      background: transparent;
      border: none;
      border-radius: 4px;
      padding: 4px 6px;
      cursor: pointer;
      font-size: 16px;
      color: #6e6e80;
      transition: all 0.15s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      line-height: 1;
    }

    .copy-button:hover {
      background: #f4f4f4;
      color: #1a1a1a;
    }

    .copy-button.copied {
      background: #f4f4f4;
      color: #10a37f;
    }

    .message.bot {
      position: relative;
    }

    .message.bot .message-content {
      margin-bottom: 0;
    }

    /* Feedback buttons - ChatGPT style */
    .feedback-buttons {
      display: flex;
      gap: 4px;
      margin-top: -6px;
      align-items: center;
    }

    .feedback-btn {
      background: transparent;
      border: none;
      border-radius: 4px;
      padding: 4px 6px;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.15s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: #6e6e80;
      width: 28px;
      height: 28px;
      line-height: 1;
    }

    .feedback-btn:hover {
      background: #f4f4f4;
      color: #1a1a1a;
    }

    .feedback-btn.selected {
      background: #f4f4f4;
      color: #1a1a1a;
    }

    .feedback-btn.thumbs-up.selected {
      color: #10a37f;
    }

    .feedback-btn.thumbs-down.selected {
      color: #ef4444;
    }

    /* Emoji button styling - emojis don't need filters */

    .feedback-text {
      font-size: 11px;
      color: #6c757d;
      margin-left: 4px;
    }

    /* Edit button for user messages - matching feedback button style */
    .edit-button-container {
      display: flex;
      gap: 4px;
      margin-top: 4px;
      margin-right: 8px;
      align-items: center;
      justify-content: flex-end;
    }

    .edit-btn {
      background: transparent;
      border: none;
      border-radius: 4px;
      padding: 4px 6px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.15s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: #6e6e80;
      width: 28px;
      height: 28px;
    }

    .edit-btn:hover {
      background: #f4f4f4;
      color: #1a1a1a;
    }

    .edit-btn svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
    }
    
    /* Make edit button SVG match the filtered icon style */
    .edit-btn svg {
      opacity: 0.7;
    }
    
    .edit-btn:hover svg {
      opacity: 1;
    }

    /* Edit mode styles - inline editing */
    .user-message-wrapper.editing .message.user {
      padding: 0;
      border: 2px solid #0129ac;
      box-shadow: 0 0 0 1px rgba(1, 41, 172, 0.1);
    }

    .edit-textarea {
      width: 100%;
      min-height: 40px;
      padding: 10px 15px;
      border: none;
      border-radius: 20px;
      font-family: inherit;
      font-size: 16px;
      resize: none;
      box-sizing: border-box;
      line-height: 1.5;
      background: transparent;
      color: black;
      overflow: hidden;
    }

    .edit-textarea:focus {
      outline: none;
    }

    .edit-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 8px;
    }

    .edit-action-btn {
      padding: 6px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    .edit-save-btn {
      background: #0129ac;
      color: white;
    }

    .edit-save-btn:hover {
      background: #0056b3;
    }

    .edit-cancel-btn {
      background: #e9ecef;
      color: #495057;
    }

    .edit-cancel-btn:hover {
      background: #dee2e6;
    }

    /* Scroll to bottom button */
    #scroll-to-bottom-btn {
      position: fixed;
      bottom: 100px;
      right: 40px;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: #0129ac;
      color: white;
      border: none;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(1, 41, 172, 0.3);
      transition: all 0.3s ease;
      z-index: 999;
    }

    #scroll-to-bottom-btn:hover {
      background: #0056b3;
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(1, 41, 172, 0.4);
    }

    #scroll-to-bottom-btn:active {
      transform: translateY(0);
    }

    #scroll-to-bottom-btn.show {
      display: flex;
    }

    #scroll-to-bottom-btn svg {
      width: 24px;
      height: 24px;
      fill: currentColor;
    }

    #input-container {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: linear-gradient(to bottom, 
        rgba(255, 255, 255, 0) 0%, 
        rgba(255, 255, 255, 0.3) 10%, 
        rgba(255, 255, 255, 0.7) 40%, 
        rgba(255, 255, 255, 0.9) 70%, 
        rgba(255, 255, 255, 0.95) 100%);
      z-index: 1000;
    }

    .input-wrapper {
      width: 60%;
      max-width: 800px;
      display: flex;
      align-items: center;
      position: relative;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      border-radius: 25px;
      padding: 8px;
      box-shadow: 
        0 8px 25px rgba(0, 0, 0, 0.1),
        0 4px 12px rgba(0, 0, 0, 0.08),
        0 2px 6px rgba(0, 0, 0, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    #user-input {
      flex: 1;
      padding: 8px 50px 8px 15px;
      border-radius: 20px;
      border: none;
      outline: none;
      font-size: 16px;
      box-sizing: border-box;
      background: transparent;
      transition: all 0.2s ease;
    }

    #user-input:focus {
      background: rgba(255, 255, 255, 0.1);
    }

    #user-input::placeholder {
      color: rgba(0, 0, 0, 0.6);
    }

    #send-btn {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      padding: 10px 15px;
      border: none;
      border-radius: 50px;
      background: #0129ac;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 
        0 4px 12px rgba(1, 41, 172, 0.3),
        0 2px 6px rgba(1, 41, 172, 0.2);
      transition: all 0.2s ease;
    }

    #send-btn svg {
      width: 20px;
      height: 20px;
      fill: currentColor;
      stroke: currentColor;
    }

    #send-btn:hover {
      background: #0056b3;
      box-shadow: 
        0 6px 16px rgba(1, 41, 172, 0.4),
        0 3px 8px rgba(1, 41, 172, 0.3);
      transform: translateY(-50%) translateY(-0.5px);
    }

    #send-btn:active {
      transform: translateY(-50%) translateY(0.5px);
      box-shadow: 
        0 2px 8px rgba(1, 41, 172, 0.3),
        0 1px 4px rgba(1, 41, 172, 0.2);
    }

    /* Voice controls */
    .mic-btn {
      position: absolute;
      right: 60px;
      top: 50%;
      transform: translateY(-50%);
      padding: 10px;
      border: none;
      border-radius: 50%;
      background: #6c757d;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      width: 40px;
      height: 40px;
    }

    .mic-btn:hover {
      background: #5a6268;
      transform: translateY(-50%) scale(1.05);
    }

    .mic-btn.recording {
      background: #dc3545;
      animation: pulse 1.5s ease-in-out infinite;
    }

    .mic-btn.disabled {
      background: #e9ecef;
      color: #6c757d;
      cursor: not-allowed;
      opacity: 0.5;
    }

    .mic-btn svg {
      width: 20px;
      height: 20px;
      fill: currentColor;
    }

    @keyframes pulse {
      0%, 100% {
        box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7);
      }
      50% {
        box-shadow: 0 0 0 10px rgba(220, 53, 69, 0);
      }
    }

    .voice-status {
      position: absolute;
      top: -35px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      white-space: nowrap;
      display: none;
      z-index: 1001;
    }

    .voice-status.show {
      display: block;
    }

    .voice-status.recording {
      background: #dc3545;
    }

    .voice-status.transcribing {
      background: #ffc107;
      color: #000;
    }

    .voice-status.speaking {
      background: #28a745;
    }

    /* Hands-free confirmation modal */
    .modal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
    }

    .modal.show {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-content {
      background-color: white;
      padding: 30px;
      border-radius: 12px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      text-align: center;
      pointer-events: auto;
      position: relative;
      z-index: 1;
    }

    .modal-content h3 {
      margin: 0 0 15px 0;
      color: #0129ac;
      font-size: 20px;
    }

    .modal-content p {
      margin: 0 0 25px 0;
      color: #666;
      line-height: 1.6;
      font-size: 15px;
    }

    .modal-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .modal-btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      flex: 1;
      max-width: 150px;
      pointer-events: auto;
      position: relative;
      z-index: 1;
    }

    .modal-btn.primary {
      background: #0129ac;
      color: white;
    }

    .modal-btn.primary:hover {
      background: #0056b3;
    }

    .modal-btn.secondary {
      background: #f8f9fa;
      color: #495057;
      border: 1px solid #dee2e6;
    }

    .modal-btn.secondary:hover {
      background: #e9ecef;
    }

    @media (max-width: 768px) {
      .modal-content {
        padding: 24px 20px;
        max-width: 90%;
      }

      .modal-content h3 {
        font-size: 18px;
      }

      .modal-content p {
        font-size: 14px;
      }

      .modal-buttons {
        flex-direction: column;
      }

      .modal-btn {
        max-width: 100%;
      }
    }

    /* ============================================
       MOBILE RESPONSIVE STYLES
       Keep sizes same, use space better
       ============================================ */
    
    @media (max-width: 768px) {
      /* Header adjustments for mobile */
      header {
        padding: 12px 16px;
        flex-wrap: wrap;
        gap: 8px;
      }

      header h1 {
        font-size: 22px !important;
        flex: 1;
        min-width: 0;
      }

      .header-controls {
        gap: 8px;
        flex-wrap: wrap;
      }

      /* Larger buttons on mobile - use available space */
      .voice-toggle-btn,
      .new-chat-btn {
        padding: 12px 18px !important;
        font-size: 15px !important;
        min-width: auto;
        flex: 1;
        min-width: 100px;
      }

      .voice-toggle-btn svg,
      .new-chat-btn svg {
        width: 22px !important;
        height: 22px !important;
      }

      /* User menu adjustments */
      .user-menu {
        flex-shrink: 0;
      }

      .user-avatar {
        width: 36px !important;
        height: 36px !important;
        font-size: 16px !important;
      }

      .user-name {
        font-size: 14px !important;
      }

      /* Main content - remove horizontal padding on mobile */
      .main-content {
        padding: 80px 0px 100px 0px !important;
        align-items: stretch !important; /* Allow messages to stretch to edges */
      }

      /* Messages container */
      #messages {
        width: 100% !important;
      }

      /* Chat messages - remove horizontal margins, keep only vertical */
      .message {
        padding: 14px 18px !important;
        margin: 10px 0px !important; /* Remove left/right margin */
        max-width: 85% !important;
        font-size: 16px !important;
        line-height: 1.5 !important;
      }

      /* User message wrapper - align to right edge */
      .user-message-wrapper {
        max-width: 85% !important;
        margin: 10px 0px 10px auto !important; /* Remove left/right margin */
      }
      
      /* Bot messages stay on left by default (margin-right: auto is implicit) */

      .user-message-wrapper.editing {
        max-width: 85% !important;
      }

      /* Bot message content - better spacing */
      .bot {
        padding: 14px 18px 50px 18px !important;
      }

      .message-content {
        font-size: 16px !important;
        line-height: 1.6 !important;
      }

      /* Larger feedback buttons on mobile */
      .feedback-buttons {
        gap: 8px !important;
        margin-top: 8px !important;
      }

      .copy-button,
      .feedback-btn {
        width: 40px !important;
        height: 40px !important;
        font-size: 20px !important;
        padding: 8px !important;
      }

      .edit-button-container {
        gap: 8px !important;
        margin-top: 8px !important;
      }

      .edit-btn {
        width: 36px !important;
        height: 36px !important;
        font-size: 16px !important;
      }

      /* Input container - minimal padding to show rounded corners */
      #input-container {
        padding: 12px 8px !important; /* Small horizontal padding to show rounded corners */
        bottom: 0 !important;
        left: 0 !important;
        right: 0 !important;
        width: 100% !important;
      }

      .input-wrapper {
        padding: 12px 16px !important;
        border-radius: 24px !important; /* Keep rounded corners */
        margin: 0 !important;
        width: 100% !important; /* Full width on mobile */
        max-width: none !important; /* Remove max-width constraint */
        box-sizing: border-box !important;
      }

      #user-input {
        padding: 12px 120px 12px 16px !important;
        font-size: 17px !important;
        line-height: 1.5 !important;
      }

      /* Larger send and mic buttons */
      #send-btn {
        right: 10px !important;
        padding: 12px 16px !important;
        width: 48px !important;
        height: 48px !important;
      }

      #send-btn svg {
        width: 24px !important;
        height: 24px !important;
      }

      .mic-btn {
        right: 65px !important;
        width: 48px !important;
        height: 48px !important;
        padding: 12px !important;
      }

      .mic-btn svg {
        width: 24px !important;
        height: 24px !important;
      }

      /* Voice status - larger text */
      .voice-status {
        font-size: 14px !important;
        padding: 8px 14px !important;
        top: -40px !important;
      }

      /* Scroll to bottom button - larger */
      #scroll-to-bottom-btn {
        width: 48px !important;
        height: 48px !important;
        padding: 12px !important;
        right: 16px !important;
        bottom: 80px !important;
      }

      #scroll-to-bottom-btn svg {
        width: 24px !important;
        height: 24px !important;
      }

      /* Markdown content - better readability */
      .bot h1 {
        font-size: 1.6em !important;
        margin: 12px 0 8px 0 !important;
      }

      .bot h2 {
        font-size: 1.4em !important;
        margin: 12px 0 8px 0 !important;
      }

      .bot h3 {
        font-size: 1.2em !important;
        margin: 10px 0 6px 0 !important;
      }

      .bot ul,
      .bot ol {
        margin: 12px 0 !important;
        padding-left: 24px !important;
      }

      .bot li {
        margin: 8px 0 !important;
        line-height: 1.6 !important;
      }

      .bot code {
        font-size: 0.95em !important;
        padding: 3px 6px !important;
      }

      .bot pre {
        padding: 12px !important;
        margin: 12px 0 !important;
      }

      .bot blockquote {
        margin: 12px 0 !important;
        padding-left: 18px !important;
      }

      /* Thinking animation - larger */
      .thinking {
        font-size: 16px !important;
        gap: 10px !important;
      }

      .thinking-dots span {
        width: 8px !important;
        height: 8px !important;
      }

      /* User dropdown - full width on mobile */
      .user-dropdown {
        right: 0 !important;
        left: auto !important;
        min-width: 200px !important;
      }

      .dropdown-item {
        padding: 12px 16px !important;
        font-size: 15px !important;
      }
    }

    /* Extra small devices (phones in portrait) */
    @media (max-width: 480px) {
      header {
        padding: 10px 12px !important;
      }

      header h1 {
        font-size: 20px !important;
      }

      .voice-toggle-btn,
      .new-chat-btn {
        padding: 10px 14px !important;
        font-size: 14px !important;
      }

      .main-content {
        padding: 75px 0px 95px 0px !important;
        align-items: stretch !important;
      }

      #messages {
        width: 100% !important;
      }

      .message {
        padding: 12px 16px !important;
        margin: 10px 0px !important;
        max-width: 90% !important;
      }

      .user-message-wrapper {
        max-width: 90% !important;
        margin: 10px 0px 10px auto !important;
      }

      #input-container {
        padding: 10px 6px !important;
        left: 0 !important;
        right: 0 !important;
        width: 100% !important;
      }

      .input-wrapper {
        padding: 10px 14px !important;
        border-radius: 20px !important;
        margin: 0 !important;
        width: 100% !important;
        max-width: none !important;
        box-sizing: border-box !important;
      }

      #user-input {
        padding: 10px 110px 10px 14px !important;
        font-size: 16px !important;
      }

      #send-btn,
      .mic-btn {
        width: 44px !important;
        height: 44px !important;
      }

      .mic-btn {
        right: 60px !important;
      }
    }

    /* Evaluation Toggle Switch */
    .evaluation-toggle {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      background: #f5f5f5;
      border-radius: 8px;
      margin: 10px 0;
    }

    .evaluation-toggle label {
      font-weight: 600;
      color: #333;
      font-size: 14px;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 24px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .toggle-slider {
      background-color: #4CAF50;
    }

    input:checked + .toggle-slider:before {
      transform: translateX(26px);
    }

    #evaluationStatus {
      color: #666;
      font-size: 14px;
    }

    #evaluationLatency {
      color: #999;
      font-size: 12px;
      margin-left: 10px;
    }
  </style>
  <!-- Favicon removed - add your own icon if needed -->
</head>
<body>

  
  <header>
    <h1 style="margin: 0; font-size: 24px; color: #0129ac;">HealthYoda</h1>
    <div class="header-controls">
      <button class="voice-toggle-btn" id="voiceToggleBtn" title="Toggle voice mode">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
          <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
        </svg>
        <span>Voice Off</span>
      </button>

      <!-- Model Selector -->
      <div class="model-selector" id="modelSelector">
        <button class="model-select-btn" id="modelSelectBtn" title="Select AI model">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
            <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
          </svg>
          <span id="activeModelName">Loading...</span>
          <span class="model-dropdown-arrow">‚ñº</span>
        </button>
        <div class="model-dropdown" id="modelDropdown">
          <div class="model-option" data-model="loading">
            <div class="model-info">
              <div class="model-name">Loading models...</div>
              <div class="model-provider">Please wait</div>
            </div>
          </div>
        </div>
      </div>

      <button class="new-chat-btn" id="newChatBtn">
        <span>
          <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg" class="icon" aria-hidden="true">
            <path d="M2.6687 11.333V8.66699C2.6687 7.74455 2.66841 7.01205 2.71655 6.42285C2.76533 5.82612 2.86699 5.31731 3.10425 4.85156L3.25854 4.57617C3.64272 3.94975 4.19392 3.43995 4.85229 3.10449L5.02905 3.02149C5.44666 2.84233 5.90133 2.75849 6.42358 2.71582C7.01272 2.66769 7.74445 2.66797 8.66675 2.66797H9.16675C9.53393 2.66797 9.83165 2.96586 9.83179 3.33301C9.83179 3.70028 9.53402 3.99805 9.16675 3.99805H8.66675C7.7226 3.99805 7.05438 3.99834 6.53198 4.04102C6.14611 4.07254 5.87277 4.12568 5.65601 4.20313L5.45581 4.28906C5.01645 4.51293 4.64872 4.85345 4.39233 5.27149L4.28979 5.45508C4.16388 5.7022 4.08381 6.01663 4.04175 6.53125C3.99906 7.05373 3.99878 7.7226 3.99878 8.66699V11.333C3.99878 12.2774 3.99906 12.9463 4.04175 13.4688C4.08381 13.9833 4.16389 14.2978 4.28979 14.5449L4.39233 14.7285C4.64871 15.1465 5.01648 15.4871 5.45581 15.7109L5.65601 15.7969C5.87276 15.8743 6.14614 15.9265 6.53198 15.958C7.05439 16.0007 7.72256 16.002 8.66675 16.002H11.3337C12.2779 16.002 12.9461 16.0007 13.4685 15.958C13.9829 15.916 14.2976 15.8367 14.5447 15.7109L14.7292 15.6074C15.147 15.3511 15.4879 14.9841 15.7117 14.5449L15.7976 14.3447C15.8751 14.128 15.9272 13.8546 15.9587 13.4688C16.0014 12.9463 16.0017 12.2774 16.0017 11.333V10.833C16.0018 10.466 16.2997 10.1681 16.6667 10.168C17.0339 10.168 17.3316 10.4659 17.3318 10.833V11.333C17.3318 12.2555 17.3331 12.9879 17.2849 13.5771C17.2422 14.0993 17.1584 14.5541 16.9792 14.9717L16.8962 15.1484C16.5609 15.8066 16.0507 16.3571 15.4246 16.7412L15.1492 16.8955C14.6833 17.1329 14.1739 17.2354 13.5769 17.2842C12.9878 17.3323 12.256 17.332 11.3337 17.332H8.66675C7.74446 17.332 7.01271 17.3323 6.42358 17.2842C5.90135 17.2415 5.44665 17.1577 5.02905 16.9785L4.85229 16.8955C4.19396 16.5601 3.64271 16.0502 3.25854 15.4238L3.10425 15.1484C2.86697 14.6827 2.76534 14.1739 2.71655 13.5771C2.66841 12.9879 2.6687 12.2555 2.6687 11.333ZM13.4646 3.11328C14.4201 2.334 15.8288 2.38969 16.7195 3.28027L16.8865 3.46485C17.6141 4.35685 17.6143 5.64423 16.8865 6.53613L16.7195 6.7207L11.6726 11.7686C11.1373 12.3039 10.4624 12.6746 9.72827 12.8408L9.41089 12.8994L7.59351 13.1582C7.38637 13.1877 7.17701 13.1187 7.02905 12.9707C6.88112 12.8227 6.81199 12.6134 6.84155 12.4063L7.10132 10.5898L7.15991 10.2715C7.3262 9.53749 7.69692 8.86241 8.23218 8.32715L13.2791 3.28027L13.4646 3.11328ZM15.7791 4.2207C15.3753 3.81702 14.7366 3.79124 14.3035 4.14453L14.2195 4.2207L9.17261 9.26856C8.81541 9.62578 8.56774 10.0756 8.45679 10.5654L8.41772 10.7773L8.28296 11.7158L9.22241 11.582L9.43433 11.543C9.92426 11.432 10.3749 11.1844 10.7322 10.8271L15.7791 5.78027L15.8552 5.69629C16.185 5.29194 16.1852 4.708 15.8552 4.30371L15.7791 4.2207Z"></path>
          </svg>
        </span>
        <span>New Chat</span>
      </button>

      <!-- Evaluation Toggle -->
      <div class="evaluation-toggle">
        <label style="font-weight: 600; color: #333;">
          Evaluations:
        </label>
        <label class="toggle-switch">
          <input type="checkbox" id="evaluationToggle" onchange="toggleEvaluations()">
          <span class="toggle-slider"></span>
        </label>
        <span id="evaluationStatus" style="color: #666; font-size: 14px;">Disabled</span>
        <span id="evaluationLatency" style="color: #999; font-size: 12px; margin-left: 10px;"></span>
      </div>

      <div class="user-menu" id="userMenu">
      <div class="user-menu" id="userMenu">
      <div class="user-info">
        <div class="user-avatar" id="userAvatar">U</div>
        <span class="user-name" id="userName">User</span>
        <div class="dropdown-arrow"></div>
      </div>
        <div class="user-dropdown" id="userDropdown">
          <div class="dropdown-item" id="userEmail">HealthYoda User</div>
          <div class="dropdown-item logout" id="logoutBtn">
            <span>
              <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg" class="icon" aria-hidden="true">
                <path d="M3.50171 12.6663V7.33333C3.50171 6.64424 3.50106 6.08728 3.53784 5.63704C3.57525 5.17925 3.65463 4.77342 3.84644 4.39681L3.96851 4.17806C4.2726 3.68235 4.70919 3.2785 5.23023 3.01302L5.3728 2.94661C5.7091 2.80238 6.06981 2.73717 6.47046 2.70443C6.9207 2.66764 7.47766 2.66829 8.16675 2.66829H9.16675L9.30054 2.68197C9.60367 2.7439 9.83179 3.0119 9.83179 3.33333C9.83179 3.65476 9.60367 3.92277 9.30054 3.9847L9.16675 3.99837H8.16675C7.45571 3.99837 6.96238 3.99926 6.57886 4.0306C6.297 4.05363 6.10737 4.09049 5.96362 4.14193L5.83374 4.19857C5.53148 4.35259 5.27861 4.58671 5.1023 4.87435L5.03198 5.00032C4.95147 5.15833 4.89472 5.36974 4.86401 5.74544C4.83268 6.12896 4.83179 6.6223 4.83179 7.33333V12.6663C4.83179 13.3772 4.8327 13.8707 4.86401 14.2542C4.8947 14.6298 4.95153 14.8414 5.03198 14.9993L5.1023 15.1263C5.27861 15.4137 5.53163 15.6482 5.83374 15.8021L5.96362 15.8577C6.1074 15.9092 6.29691 15.947 6.57886 15.9701C6.96238 16.0014 7.45571 16.0013 8.16675 16.0013H9.16675L9.30054 16.015C9.6036 16.0769 9.83163 16.345 9.83179 16.6663C9.83179 16.9877 9.60363 17.2558 9.30054 17.3177L9.16675 17.3314H8.16675C7.47766 17.3314 6.9207 17.332 6.47046 17.2952C6.06978 17.2625 5.70912 17.1973 5.3728 17.0531L5.23023 16.9867C4.70911 16.7211 4.27261 16.3174 3.96851 15.8216L3.84644 15.6038C3.65447 15.2271 3.57526 14.8206 3.53784 14.3626C3.50107 13.9124 3.50171 13.3553 3.50171 12.6663ZM13.8035 13.804C13.5438 14.0634 13.1226 14.0635 12.863 13.804C12.6033 13.5443 12.6033 13.1223 12.863 12.8626L13.8035 13.804ZM12.863 6.19661C13.0903 5.96939 13.4409 5.94126 13.699 6.11165L13.8035 6.19661L17.1375 9.52962C17.3969 9.78923 17.3968 10.2104 17.1375 10.4701L13.8035 13.804L13.3337 13.3333L12.863 12.8626L15.0603 10.6654H9.16675C8.79959 10.6654 8.50189 10.3674 8.50171 10.0003C8.50171 9.63306 8.79948 9.33529 9.16675 9.33529H15.0613L12.863 7.13704L12.7781 7.03255C12.6077 6.77449 12.6359 6.42386 12.863 6.19661Z"></path>
              </svg>
            </span>
            <span>Logout</span>
          </div>
        </div>
      </div>
    </div>
  </header>

  <div class="main-content">
    <div id="messages"></div>
  </div>

  <!-- Scroll to bottom button -->
  <button id="scroll-to-bottom-btn" title="Scroll to bottom">
    <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
      <path d="M9.33468 3.33333C9.33468 2.96617 9.6326 2.66847 9.99972 2.66829C10.367 2.66829 10.6648 2.96606 10.6648 3.33333V15.0609L15.363 10.3626L15.4675 10.2777C15.7255 10.1074 16.0762 10.1357 16.3034 10.3626C16.5631 10.6223 16.5631 11.0443 16.3034 11.304L10.4704 17.137C10.2108 17.3967 9.7897 17.3966 9.52999 17.137L3.69601 11.304L3.61105 11.1995C3.44054 10.9414 3.46874 10.5899 3.69601 10.3626C3.92328 10.1354 4.27479 10.1072 4.53292 10.2777L4.63741 10.3626L9.33468 15.0599V3.33333Z"></path>
    </svg>
  </button>

  <div id="input-container">
    <div class="input-wrapper">
      <div class="voice-status" id="voiceStatus"></div>
      <input type="text" id="user-input" placeholder="Type your question...">
      <button class="mic-btn disabled" id="micBtn" title="Push to talk">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
          <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
        </svg>
      </button>
      <button id="send-btn">
        <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg">
          <path fill="none" d="M0 0h24v24H0z"></path>
          <path d="M2.01 21 23 12 2.01 3 2 10l15 2-15 2z"></path>
        </svg>
      </button>
    </div>
  </div>

  <script>
    // API Base URL configuration
    function getApiBase() {
      const protocol = window.location.protocol;
      const hostname = window.location.hostname;
      
      // If opened as file://, default to localhost backend
      if (protocol === 'file:' || !hostname || hostname === '') {
        return 'http://127.0.0.1:8002';
      }
      
      // Development environment
      if (hostname === 'localhost' || hostname === '127.0.0.1') {
        return 'http://127.0.0.1:8002';
      }
      
      // Default fallback - use current origin
      return window.location.origin;
    }

    const messagesDiv = document.getElementById("messages");
    const input = document.getElementById("user-input");
    const sendBtn = document.getElementById("send-btn");

    
    // Generate a FRESH session ID for each page load (new conversation)
    // This ensures each time user opens chatbot, it's a NEW session
    const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
    const timestamp = new Date().getTime().toString().slice(-6); // Last 6 digits of timestamp
    const randomId = Math.random().toString(36).substr(2, 6);
    let sessionId = `cf.conversation.${date}.${timestamp}${randomId}`;
    
    // Store the new session
    localStorage.setItem('chatbot_session_id', sessionId);
    
    // Timing helper function
    function logTiming(stepName, startTime) {
      const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
      console.log(`[TIMING] ${stepName}: ${elapsed}s`);
      return performance.now(); // Return new start time for chaining
    }
    
    // Flag to prevent duplicate greetings
    let greetingSent = false;

    // Helper function to remove edit button from previous user messages
    function removeAllEditButtons() {
      const allWrappers = messagesDiv.querySelectorAll('.user-message-wrapper');
      allWrappers.forEach(wrapper => {
        const editContainer = wrapper.querySelector('.edit-button-container');
        if (editContainer) {
          editContainer.remove();
        }
      });
    }

    function addMessage(content, sender) {
      if (sender === "user") {
        // Remove edit button from any previous user messages
        removeAllEditButtons();
        
        // For user messages, create wrapper with message and edit button below
        const wrapper = document.createElement("div");
        wrapper.className = "user-message-wrapper";
        wrapper.innerHTML = `
          <div class="message user">${content}</div>
          <div class="edit-button-container">
            <button class="edit-btn" onclick="editMessage(this)" title="Edit message">
              <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
              </svg>
            </button>
          </div>
        `;
        messagesDiv.appendChild(wrapper);
        // Message added
        scrollToBottom();
        return wrapper;
      } else {
        // For bot messages, keep simple structure
        const div = document.createElement("div");
        div.className = "message " + sender;
        div.innerText = content;
        messagesDiv.appendChild(div);
        // Message added
        scrollToBottom();
        return div;
      }
    }

    function addMessageHTML(content, sender, traceId = null) {
      const div = document.createElement("div");
      div.className = "message " + sender;
      
      if (sender === "bot") {
        // For bot messages, wrap content and add copy button + feedback buttons
        div.innerHTML = `
          <div class="message-content">${content}</div>
          <div class="feedback-buttons">
            <button class="copy-button" onclick="copyMessage(this)" title="Copy message">
              üìã
            </button>
            <button class="feedback-btn thumbs-up" onclick="submitFeedback(this, 'thumbs_up')" title="Good response">
              üëç
            </button>
            <button class="feedback-btn thumbs-down" onclick="submitFeedback(this, 'thumbs_down')" title="Bad response">
              üëé
            </button>
            <span class="feedback-text"></span>
          </div>
        `;
        
        // Store trace_id if provided
        if (traceId) {
          div.dataset.traceId = traceId;
        }
      } else {
        // For user messages, keep as is
        div.innerHTML = content;
      }
      
      messagesDiv.appendChild(div);
      // Message HTML added
      scrollToBottom();
      return div;
    }

    function renderMarkdown(text) {
      if (typeof marked !== 'undefined') {
        return marked.parse(text);
      } else {
        // Fallback: basic markdown-like formatting
        return text
          .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
          .replace(/\*(.*?)\*/g, '<em>$1</em>')
          .replace(/`(.*?)`/g, '<code>$1</code>')
          .replace(/^### (.*$)/gim, '<h3>$1</h3>')
          .replace(/^## (.*$)/gim, '<h2>$1</h2>')
          .replace(/^# (.*$)/gim, '<h1>$1</h1>')
          .replace(/^\* (.*$)/gim, '<li>$1</li>')
          .replace(/^\d+\. (.*$)/gim, '<li>$1</li>')
          .replace(/\n/g, '<br>');
      }
    }

    // Scroll mode state management
    let scrollMode = 'auto'; // 'auto' or 'manual'
    let isStreaming = false; // Track if bot is currently streaming
    let userInteractionTimeout = null; // Debounce user interaction detection
    const scrollToBottomBtn = document.getElementById('scroll-to-bottom-btn');
    
    // Update button visibility based on mode
    function updateButtonVisibility() {
      if (scrollMode === 'manual') {
        scrollToBottomBtn.classList.add('show');
      } else {
        scrollToBottomBtn.classList.remove('show');
      }
    }
    
    function scrollToBottom() {
      // Only auto-scroll if in auto mode
      if (scrollMode !== 'auto') {
        // Skipping auto-scroll
        return;
      }
      
      // Use requestAnimationFrame to ensure DOM is updated before scrolling
      requestAnimationFrame(() => {
        // Scroll to the very bottom of the page
        window.scrollTo({
          top: document.body.scrollHeight,
          behavior: 'smooth' // Use smooth for better UX
        });
      });
    }
    
    // Check if user is at the bottom of the page
    function isAtBottom() {
      const scrollThreshold = 100; // pixels from bottom to be considered "at bottom"
      const atBottom = (window.innerHeight + window.scrollY) >= (document.body.scrollHeight - scrollThreshold);
      return atBottom;
    }
    
    // Handle user wheel/scroll gestures (actual user interaction)
    function handleUserScrollGesture(event) {
      // Only care if we're in auto mode (manual mode already stops scrolling)
      if (scrollMode !== 'auto') {
        return;
      }
      
      // User scroll detected
      
      // Check if user is scrolling up (negative deltaY)
      const scrollingUp = event.deltaY < 0;
      
      if (scrollingUp) {
        // User is trying to scroll up - switch to manual mode
        scrollMode = 'manual';
        updateButtonVisibility();
        // Switched to MANUAL mode
      }
    }
    
    // Handle touch scrolling on mobile
    let touchStartY = 0;
    function handleTouchStart(event) {
      if (event.touches.length > 0) {
        touchStartY = event.touches[0].clientY;
      }
    }
    
    function handleTouchMove(event) {
      if (scrollMode !== 'auto') {
        return;
      }
      
      if (event.touches.length > 0) {
        const touchEndY = event.touches[0].clientY;
        const deltaY = touchEndY - touchStartY;
        
        // Scrolling up has positive deltaY (finger moves down)
        if (deltaY > 10) {
          scrollMode = 'manual';
          updateButtonVisibility();
          // Switched to MANUAL mode (touch)
        }
      }
    }
    
    // Monitor scroll position to switch back to auto when at bottom
    function checkScrollPosition() {
      // Check if we're in manual mode and user scrolled to bottom
      // (works during streaming AND after streaming ends)
      if (scrollMode === 'manual' && isAtBottom()) {
        // User manually scrolled back to bottom - switch to auto
        scrollMode = 'auto';
        updateButtonVisibility();
        // Switched to AUTO mode
      }
    }
    
    // Handle scroll to bottom button click
    function handleScrollToBottomClick() {
      // Scroll button clicked
      scrollMode = 'auto';
      updateButtonVisibility();
      window.scrollTo({
        top: document.body.scrollHeight,
        behavior: 'smooth'
      });
    }
    
    // Add event listeners for user scroll gestures
    window.addEventListener('wheel', handleUserScrollGesture, { passive: true });
    window.addEventListener('touchstart', handleTouchStart, { passive: true });
    window.addEventListener('touchmove', handleTouchMove, { passive: true });
    
    // Check scroll position periodically to switch back to auto mode
    window.addEventListener('scroll', checkScrollPosition, { passive: true });
    
    // Add click event listener to scroll button
    scrollToBottomBtn.addEventListener('click', handleScrollToBottomClick);

    // Submit feedback functionality - sends to backend for Langfuse logging
    async function submitFeedback(button, rating) {
      try {
        const messageDiv = button.closest('.message.bot');
        const traceId = messageDiv.dataset.traceId || messageDiv.dataset.traceid;
        const generationId = messageDiv.dataset.generationId || messageDiv.dataset.generationid;
        
        // Check if feedback already submitted
        if (messageDiv.dataset.feedbackSubmitted === 'true') {
          // Feedback already submitted
          return;
        }
        
        // Disable all feedback buttons immediately to prevent double-clicking
        const feedbackButtons = messageDiv.querySelectorAll('.feedback-btn');
        feedbackButtons.forEach(btn => {
          btn.disabled = true;
          btn.style.cursor = 'not-allowed';
          btn.style.opacity = '0.5';
        });
        
        // Mark as submitted to prevent future submissions
        messageDiv.dataset.feedbackSubmitted = 'true';
        
        // Update UI to show which button was clicked
        feedbackButtons.forEach(btn => btn.classList.remove('selected'));
        button.classList.add('selected');
        
        // Show feedback text
        const feedbackText = messageDiv.querySelector('.feedback-text');
        feedbackText.textContent = 'Submitting...';
        
        // Send feedback to backend if trace_id exists
        if (traceId) {
          try {
            const apiBase = getApiBase();
            const feedbackPayload = {
              trace_id: traceId,
              rating: rating,
              comment: ""
            };
            
            // Add generation_id if available
            if (generationId) {
              feedbackPayload.generation_id = generationId;
            }
            
            const response = await fetch(`${apiBase}/feedback`, {
              method: "POST",
              headers: { 
                "Content-Type": "application/json"
              },
              body: JSON.stringify(feedbackPayload),
            });
            
            if (response.ok) {
              const data = await response.json();
              // Feedback submitted
              feedbackText.textContent = rating === 'thumbs_up' ? 'Thanks for your feedback!' : 'Thanks! We\'ll improve.';
            } else {
              console.error("Failed to submit feedback to backend");
              feedbackText.textContent = 'Feedback saved locally';
            }
          } catch (error) {
            console.error("Error submitting feedback to backend:", error);
            feedbackText.textContent = 'Feedback saved locally';
          }
        } else {
          feedbackText.textContent = rating === 'thumbs_up' ? 'Thanks for your feedback!' : 'Thanks! We\'ll improve.';
        }
        
        // Clear feedback text after 3 seconds
        setTimeout(() => {
          feedbackText.textContent = '';
        }, 3000);
        
      } catch (error) {
        console.error("Error submitting feedback:", error);
        
        // Re-enable buttons on error
        const messageDiv = button.closest('.message.bot');
        const feedbackButtons = messageDiv.querySelectorAll('.feedback-btn');
        feedbackButtons.forEach(btn => {
          btn.disabled = false;
          btn.style.cursor = 'pointer';
          btn.style.opacity = '1';
        });
        messageDiv.dataset.feedbackSubmitted = 'false';
      }
    }

    // Copy message functionality
    async function copyMessage(button) {
      try {
        // Get the message content (text only, without HTML)
        const messageDiv = button.closest('.message.bot');
        const contentDiv = messageDiv.querySelector('.message-content');
        
        // Extract text content from the HTML
        const textContent = contentDiv.textContent || contentDiv.innerText || '';
        
        // Copy to clipboard
        await navigator.clipboard.writeText(textContent);
        
        // Show success feedback
        const originalHTML = button.innerHTML;
        button.innerHTML = '<span style="color: #10a37f;">‚úì</span>';
        button.classList.add('copied');
        
        // Reset after 2 seconds
        setTimeout(() => {
          button.innerHTML = originalHTML;
          button.classList.remove('copied');
        }, 2000);
        
      } catch (err) {
        console.error('Failed to copy text: ', err);
        
        // Fallback: show error feedback
        const originalHTML = button.innerHTML;
        button.innerHTML = '<span style="color: #721c24;">‚ùå</span>';
        button.style.background = '#f8d7da';
        
        // Reset after 2 seconds
        setTimeout(() => {
          button.innerHTML = originalHTML;
          button.style.background = '';
        }, 2000);
      }
    }

    // Auto-resize textarea to fit content
    function autoResizeTextarea(textarea) {
      textarea.style.height = 'auto';
      textarea.style.height = textarea.scrollHeight + 'px';
    }

    // Edit message functionality - inline editing
    function editMessage(button) {
      const wrapper = button.closest('.user-message-wrapper');
      const messageDiv = wrapper.querySelector('.message.user');
      const originalText = messageDiv.textContent || messageDiv.innerText || '';
      
      // Store original content and width for cancel
      wrapper.dataset.originalContent = originalText;
      const originalWidth = messageDiv.offsetWidth;
      wrapper.dataset.originalWidth = originalWidth;
      
      // Add editing class to wrapper
      wrapper.classList.add('editing');
      
      // Set minimum width to preserve message size
      messageDiv.style.minWidth = originalWidth + 'px';
      
      // Replace message content with textarea and buttons
      messageDiv.innerHTML = `<textarea class="edit-textarea" autofocus>${originalText}</textarea>`;
      
      // Hide edit button and add action buttons
      const editButtonContainer = wrapper.querySelector('.edit-button-container');
      editButtonContainer.style.display = 'none';
      
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'edit-actions';
      actionsDiv.innerHTML = `
        <button class="edit-action-btn edit-cancel-btn" onclick="cancelEdit(this)">Cancel</button>
        <button class="edit-action-btn edit-save-btn" onclick="saveEdit(this)">Save & Resend</button>
      `;
      wrapper.appendChild(actionsDiv);
      
      // Focus textarea and move cursor to end
      const textarea = messageDiv.querySelector('.edit-textarea');
      
      // Auto-resize textarea to fit content
      autoResizeTextarea(textarea);
      
      // Add input event listener for auto-resize
      textarea.addEventListener('input', () => autoResizeTextarea(textarea));
      
      textarea.focus();
      textarea.setSelectionRange(textarea.value.length, textarea.value.length);
      
      // Add keyboard shortcuts
      textarea.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          saveEdit(wrapper.querySelector('.edit-save-btn'));
        } else if (e.key === 'Escape') {
          e.preventDefault();
          cancelEdit(wrapper.querySelector('.edit-cancel-btn'));
        }
      });
    }

    // Cancel edit and restore original content
    function cancelEdit(button) {
      const wrapper = button.closest('.user-message-wrapper');
      const originalContent = wrapper.dataset.originalContent || '';
      const messageDiv = wrapper.querySelector('.message.user');
      
      // Remove editing class
      wrapper.classList.remove('editing');
      
      // Remove min-width constraint
      messageDiv.style.minWidth = '';
      
      // Restore original message content
      messageDiv.innerHTML = originalContent;
      
      // Remove action buttons
      const actionsDiv = wrapper.querySelector('.edit-actions');
      if (actionsDiv) {
        actionsDiv.remove();
      }
      
      // Show edit button again
      const editButtonContainer = wrapper.querySelector('.edit-button-container');
      if (editButtonContainer) {
        editButtonContainer.style.display = 'flex';
      }
    }

    // Save edited message and resend
    async function saveEdit(button) {
      const wrapper = button.closest('.user-message-wrapper');
      const textarea = wrapper.querySelector('.edit-textarea');
      const newText = textarea.value.trim();
      
      if (!newText) {
        alert('Message cannot be empty');
        return;
      }
      
      const messageDiv = wrapper.querySelector('.message.user');
      
      // Remove editing class
      wrapper.classList.remove('editing');
      
      // Remove min-width constraint
      messageDiv.style.minWidth = '';
      
      // Update message content with new text
      messageDiv.innerHTML = newText;
      
      // Remove action buttons
      const actionsDiv = wrapper.querySelector('.edit-actions');
      if (actionsDiv) {
        actionsDiv.remove();
      }
      
      // Show edit button again
      const editButtonContainer = wrapper.querySelector('.edit-button-container');
      if (editButtonContainer) {
        editButtonContainer.style.display = 'flex';
      }
      
      // Remove all messages after this one from DOM
      let nextSibling = wrapper.nextElementSibling;
      while (nextSibling) {
        const toRemove = nextSibling;
        nextSibling = nextSibling.nextElementSibling;
        toRemove.remove();
      }
      
      // Message edited
      
      // Update chat history on server
      await updateChatHistoryAfterEdit(wrapper, newText);
      
      // Resend the edited message
      await sendMessageText(newText);
    }
    
    // Update chat history on server after editing (simplified - no auth)
    async function updateChatHistoryAfterEdit(editedWrapper, editedText) {
      // For now, we'll just update local state
      // Server-side history updates are optional without authentication
      // Message edited locally
    }

    // Send message with specific text (used for editing)
    async function sendMessageText(questionText) {
      if (!questionText) return;
      
      const startTime = performance.now();
      console.log('[STEP] Generating Response from RAG...');
      
      // Store question in outer scope for tree branch logging
      const question = questionText;

      // Show thinking animation
      const botDiv = addMessageHTML("", "bot");
      botDiv.innerHTML = `
        <div class="thinking">
          Thinking
          <span class="thinking-dots">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
      `;

      // Force another scroll to ensure thinking is visible
      setTimeout(() => scrollToBottom(), 50);

      // Start streaming - enable scroll tracking
      isStreaming = true;
      scrollMode = 'auto'; // Reset to auto mode for new message
      updateButtonVisibility(); // Ensure button is hidden in auto mode
      try {
        const requestBody = { question };
        
        // Send session_id for session continuity
        requestBody.session_id = sessionId;
        
        // Use streaming endpoint for real-time responses
        const response = await fetch(`${getApiBase()}/chat/stream`, {
          method: "POST",
          headers: { 
            "Content-Type": "application/json"
          },
          body: JSON.stringify(requestBody),
        });

        // Response received
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        // Keep thinking animation until we get thinking_complete signal
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        let fullResponse = "";
        let lastRenderTime = 0;
        const renderThrottle = 16; // 60fps - re-render every 16ms for smooth streaming

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || ""; // Keep incomplete line in buffer
          
          for (const line of lines) {
            if (line.startsWith('data: ')) {
              try {
                const data = JSON.parse(line.slice(6));
                
                if (data.type === 'thinking_complete') {
                  // Clear thinking animation and prepare for streaming (NO BUTTONS YET)
                  botDiv.innerHTML = `<div class="message-content"></div>`;
                  // Thinking complete
                } else if (data.type === 'sources') {
                  // Log source information to browser console
                  // Sources received
                } else if (data.type === 'token') {
                  // Add token to response (STILL NO BUTTONS)
                  const token = data.token;
                  fullResponse += token;
                  
                  // Throttle rendering to improve performance
                  const now = Date.now();
                  if (now - lastRenderTime > renderThrottle) {
                    // Render markdown and update only the message content
                    const contentDiv = botDiv.querySelector('.message-content');
                    if (contentDiv) {
                      contentDiv.innerHTML = renderMarkdown(fullResponse);
                    } else {
                      // Fallback: create content div only
                      botDiv.innerHTML = `<div class="message-content">${renderMarkdown(fullResponse)}</div>`;
                    }
                    scrollToBottom();
                    lastRenderTime = now;
                  }
                } else if (data.type === 'done') {
                  // Final response received with trace_id, generation_id, and tree branch info
                  fullResponse = data.full_response || fullResponse;
                  const traceId = data.trace_id;
                  const generationId = data.generation_id;
                  const treeBranchInfo = data.tree_branch_info;
                  
                  // Log timing for RAG response generation
                  logTiming('RAG Response Generation', startTime);
                  
                  // Log tree branch info (simplified)
                  if (treeBranchInfo) {
                    console.log(`[RAG] Tree Branch: ${treeBranchInfo.tree_branch || 'Unknown'}`);
                    if (treeBranchInfo.tags && treeBranchInfo.tags.length > 0) {
                      console.log(`[RAG] Tags: ${treeBranchInfo.tags.join(', ')}`);
                    }
                  }
                  
                  // Check if response is empty
                  if (!fullResponse || fullResponse.trim() === '') {
                    console.error("[ERROR] Empty response received!");
                    fullResponse = "I apologize, but I wasn't able to generate a response. Please try again.";
                  }
                  
                  // UI Update timing
                  const uiStartTime = performance.now();
                  console.log('[STEP] Updating UI...');
                  
                  // Final render with complete response and buttons
                  botDiv.innerHTML = `
                    <div class="message-content">${renderMarkdown(fullResponse)}</div>
                    <div class="feedback-buttons">
                      <button class="copy-button" onclick="copyMessage(this)" title="Copy message">
                        üìã
                      </button>
                      <button class="feedback-btn thumbs-up" onclick="submitFeedback(this, 'thumbs_up')" title="Good response">
                        üëç
                      </button>
                      <button class="feedback-btn thumbs-down" onclick="submitFeedback(this, 'thumbs_down')" title="Bad response">
                        üëé
                      </button>
                      <span class="feedback-text"></span>
                    </div>
                  `;
                  
                  logTiming('UI Update', uiStartTime);
                  
                  // Store trace_id and generation_id on the bot message for feedback
                  if (traceId) {
                    botDiv.dataset.traceId = traceId;
                  } else {
                    // Generate a fallback trace_id for feedback functionality
                    const fallbackTraceId = 'fallback_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    botDiv.dataset.traceId = fallbackTraceId;
                  }
                  
                  // Store generation_id if available
                  if (generationId) {
                    botDiv.dataset.generationId = generationId;
                  }
                  
                  // Note: Evaluations may run in background if enabled (check toggle)
                  let evalStartTime = performance.now();
                  
                  // End streaming - keep current mode (don't force to auto)
                  isStreaming = false;
                  
                  // If voice mode enabled, speak the response
                  // In hands-free mode, recording will auto-start after speaking completes
                  if (voiceEnabled && fullResponse) {
                    await speakText(fullResponse);
                  } else if (voiceEnabled && isHandsFree && !isSpeaking) {
                    // If TTS is disabled but hands-free is on, restart recording immediately
                    setTimeout(() => {
                      if (voiceEnabled && isHandsFree && !isSpeaking && !isRecording) {
                        startRecording();
                      }
                    }, 500);
                  }
                  
                  // Continue reading stream for evaluation_complete event
                  // Don't return yet - wait for evaluation_complete
                } else if (data.type === 'evaluation_complete') {
                  // Evaluation completed - log timing
                  // Use backend duration if available, otherwise calculate from start time
                  if (data.duration !== undefined) {
                    console.log(`[TIMING] Evaluations: ${data.duration}s`);
                  } else {
                    logTiming('Evaluations', evalStartTime);
                  }
                  return; // Now we can return after evaluations complete
                } else if (data.type === 'error') {
                  throw new Error(data.error);
                }
              } catch (e) {
                console.error("[ERROR] Error parsing streaming data:", e);
              }
            }
          }
        }
        
      } catch (error) {
        logTiming('RAG Response Generation (FAILED)', startTime);
        console.error("[ERROR] Chat error:", error);
        // Clear thinking animation and show error
        botDiv.innerHTML = "Sorry, there was an error. Please try again.";
        
        // End streaming on error - keep current mode
        isStreaming = false;
      }
    }

    async function sendMessage() {
      const question = input.value.trim();
      if (!question) return;

      addMessage(question, "user");
      input.value = "";
      
      // Mark greeting as sent since user has started conversation
      greetingSent = true;
      
      // Send the message
      await sendMessageText(question);
    }

    sendBtn.addEventListener("click", sendMessage);
    input.addEventListener("keypress", (e) => { if (e.key === "Enter") sendMessage(); });

    // ===== VOICE FUNCTIONALITY =====
    
    // Voice state management
    let voiceEnabled = false;
    let isHandsFree = false; // Hands-free mode flag
    let isRecording = false;
    let isSpeaking = false;
    let mediaRecorder = null;
    let audioChunks = [];
    
    // Voice latency tracker - measures time from patient voice end to bot voice start
    // Similar to AssemblyAI's silence detection between speakers
    const voiceLatencyTracker = {
      patientSpeechEndTime: null, // When patient actually stopped speaking (silence started)
      botVoiceStartTime: null,
      isTracking: false,
      
      // Mark when patient's actual speech ends (when silence is detected, not when recording stops)
      markPatientSpeechEnd() {
        // This is called when volume drops below threshold (silence detected)
        this.patientSpeechEndTime = performance.now();
        this.isTracking = true;
        console.log('%c[LATENCY] Patient speech ended (silence detected)', 'color: #888; font-weight: normal;');
      },
      
      // Mark when bot starts speaking (when TTS playback begins)
      markBotVoiceStart() {
        if (!this.isTracking || !this.patientSpeechEndTime) {
          console.warn('%c[LATENCY] Bot voice started but no patient speech end time recorded', 'color: orange;');
          return;
        }
        
        this.botVoiceStartTime = performance.now();
        const latency = this.botVoiceStartTime - this.patientSpeechEndTime;
        const latencySeconds = (latency / 1000).toFixed(2);
        const latencyMs = latency.toFixed(0);
        
        // Display latency in RED with prominent styling
        console.log(
          `%c‚è±Ô∏è VOICE LATENCY: ${latencySeconds}s (${latencyMs}ms)`,
          'color: red; font-size: 16px; font-weight: bold; background: #ffe6e6; padding: 4px 8px; border-radius: 4px;'
        );
        
        // Additional breakdown in smaller text
        console.log(
          `%c  Patient speech ended: ${this.patientSpeechEndTime.toFixed(2)}ms | Bot voice started: ${this.botVoiceStartTime.toFixed(2)}ms`,
          'color: #666; font-size: 12px;'
        );
        
        // Reset for next measurement
        this.reset();
      },
      
      // Reset tracker for next conversation turn
      reset() {
        this.patientSpeechEndTime = null;
        this.botVoiceStartTime = null;
        this.isTracking = false;
      },
      
      // Cancel tracking if something goes wrong
      cancel() {
        if (this.isTracking) {
          console.warn('%c[LATENCY] Tracking cancelled - resetting', 'color: orange;');
          this.reset();
        }
      }
    };
    let currentAudio = null;
    let audioContext = null;
    let analyserNode = null;
    let silenceDetectionInterval = null;
    
    const voiceToggleBtn = document.getElementById('voiceToggleBtn');
    const micBtn = document.getElementById('micBtn');
    const voiceStatus = document.getElementById('voiceStatus');
    
    // Check voice availability on page load
    async function checkVoiceAvailability() {
      try {
        const response = await fetch(`${getApiBase()}/voice/status`);
        const data = await response.json();
        
        // Check if STT is available (TTS is optional)
        if (data.initialized && data.stt_available) {
          // Voice available - enable toggle button
          voiceToggleBtn.disabled = false;
        } else {
          voiceToggleBtn.disabled = true;
          voiceToggleBtn.title = 'Voice processing not available on server';
        }
      } catch (error) {
        console.error('[ERROR] Error checking voice availability:', error);
        voiceToggleBtn.disabled = true;
      }
    }
    
    // Check if getUserMedia is available
    function isGetUserMediaAvailable() {
      try {
        // Check for modern API first
        // Note: navigator.mediaDevices might be undefined in non-secure contexts
        if (navigator.mediaDevices && typeof navigator.mediaDevices.getUserMedia === 'function') {
          return true;
        }
        // Check for legacy API (deprecated but still used in some browsers)
        if (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia) {
          return true;
        }
        return false;
      } catch (e) {
        // If accessing navigator.mediaDevices throws an error, it's not available
        return false;
      }
    }
    
    // Get getUserMedia with fallback for older browsers
    function getUserMedia(constraints) {
      try {
        // Modern API
        if (navigator.mediaDevices && typeof navigator.mediaDevices.getUserMedia === 'function') {
          return navigator.mediaDevices.getUserMedia(constraints);
        }
        // Legacy API with promise wrapper
        const legacyGetUserMedia = navigator.getUserMedia || 
                                    navigator.webkitGetUserMedia || 
                                    navigator.mozGetUserMedia || 
                                    navigator.msGetUserMedia;
        
        if (legacyGetUserMedia) {
          return new Promise((resolve, reject) => {
            legacyGetUserMedia.call(navigator, constraints, resolve, reject);
          });
        }
      } catch (e) {
        console.error('[ERROR] Error accessing getUserMedia:', e);
      }
      
      // Not available
      throw new Error('getUserMedia is not supported in this browser');
    }
    
    // Check if secure context (HTTPS or localhost)
    function isSecureContext() {
      try {
        const protocol = window.location.protocol;
        const hostname = window.location.hostname;
        
        // Explicit check: HTTPS is always secure
        if (protocol === 'https:') {
          return true;
        }
        
        // Explicit check: localhost/127.0.0.1 are secure even on HTTP
        if (hostname === 'localhost' || hostname === '127.0.0.1' || hostname === '[::1]') {
          return true;
        }
        
        // For HTTP with IP address or domain name, check window.isSecureContext
        // This will be false for HTTP + IP address
        if (typeof window.isSecureContext !== 'undefined') {
          return window.isSecureContext;
        }
        
        // Default: if not HTTPS and not localhost, assume not secure
        return false;
      } catch (e) {
        // If we can't determine, assume not secure (safer)
        console.warn('[Voice] Error checking secure context:', e);
        return false;
      }
    }
    
    // Show hands-free confirmation modal
    function showHandsFreeModal() {
      const modal = document.getElementById('handsFreeModal');
      if (modal) {
        modal.classList.add('show');
      }
    }

    // Hide hands-free confirmation modal
    function hideHandsFreeModal() {
      const modal = document.getElementById('handsFreeModal');
      if (modal) {
        modal.classList.remove('show');
      }
    }

    // Start session after modal choice
    async function startSessionAfterModalChoice() {
      // Only send greeting if no messages are displayed and greeting hasn't been sent
      if (messagesDiv.children.length === 0 && !greetingSent) {
        await sendInitialGreeting();
      }
    }

    // Enable hands-free mode after confirmation
    async function enableHandsFreeMode() {
      hideHandsFreeModal();
      voiceEnabled = true;
      isHandsFree = true;
      
      voiceToggleBtn.classList.add('active');
      voiceToggleBtn.querySelector('span').textContent = 'Voice On';
      micBtn.classList.remove('disabled');
      
      // Update mic button to show it's always-on
      micBtn.title = 'Hands-free mode active - microphone always on';
      
      // Start the session (send greeting)
      await startSessionAfterModalChoice();
      
      // Start recording immediately in hands-free mode
      try {
        await startRecording();
      } catch (error) {
        console.error('[ERROR] Failed to start hands-free recording:', error);
        // If recording fails, disable hands-free mode
        voiceEnabled = false;
        isHandsFree = false;
        voiceToggleBtn.classList.remove('active');
        voiceToggleBtn.querySelector('span').textContent = 'Voice Off';
        micBtn.classList.add('disabled');
        alert('Failed to start hands-free mode. Please try again.');
      }
    }

    // Toggle voice mode
    async function toggleVoiceMode() {
      // If disabling voice mode
      if (voiceEnabled) {
        voiceEnabled = false;
        isHandsFree = false;
        voiceToggleBtn.classList.remove('active');
        voiceToggleBtn.querySelector('span').textContent = 'Voice Off';
        micBtn.classList.add('disabled');
        micBtn.title = 'Push to talk';
        stopRecording(); // Stop if currently recording
        stopSpeaking(); // Stop if currently speaking
        return;
      }
      
      // If enabling voice mode - show confirmation modal
      // Check if secure context FIRST (required for getUserMedia)
      if (!isSecureContext()) {
        console.error('[ERROR] getUserMedia requires HTTPS or localhost');
        const protocol = window.location.protocol;
        const hostname = window.location.hostname;
        let message = 'Voice mode requires a secure connection (HTTPS) or localhost.\n\n';
        
        if (protocol === 'http:' && hostname !== 'localhost' && hostname !== '127.0.0.1') {
          message += 'You are accessing the site over HTTP from an IP address.\n';
          message += 'To use voice features:\n';
          message += '1. Access via localhost: http://localhost:8003\n';
          message += '2. Or set up HTTPS in production';
        } else {
          message += 'Please access the site over HTTPS or use localhost.';
        }
        
        alert(message);
        return;
      }
      
      // Check if getUserMedia is available (only after secure context check)
      if (!isGetUserMediaAvailable()) {
        console.error('[ERROR] getUserMedia is not supported in this browser');
        alert('Voice mode is not supported in this browser. Please use a modern browser like Chrome, Firefox, or Edge.');
        return;
      }
      
      // Check microphone permission
      try {
        const stream = await getUserMedia({ audio: true });
        stream.getTracks().forEach(track => track.stop()); // Stop immediately, just checking permission
        
        // Show confirmation modal
        showHandsFreeModal();
      } catch (error) {
        console.error('[ERROR] Microphone permission denied:', error);
        let errorMessage = 'Microphone permission is required for voice mode.';
        
        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
          errorMessage = 'Microphone permission was denied. Please allow microphone access in your browser settings and try again.';
        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
          errorMessage = 'No microphone found. Please connect a microphone and try again.';
        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
          errorMessage = 'Microphone is already in use by another application. Please close other applications using the microphone.';
        } else if (error.name === 'OverconstrainedError' || error.name === 'ConstraintNotSatisfiedError') {
          errorMessage = 'Microphone constraints could not be satisfied. Please check your microphone settings.';
        }
        
        alert(errorMessage);
      }
    }
    
    // Silence detection using Web Audio API
    function startSilenceDetection(stream) {
      if (!isHandsFree) return; // Only use silence detection in hands-free mode
      
      try {
        // Create audio context and analyser
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyserNode = audioContext.createAnalyser();
        analyserNode.fftSize = 256;
        analyserNode.smoothingTimeConstant = 0.8;
        
        const source = audioContext.createMediaStreamSource(stream);
        source.connect(analyserNode);
        
        const dataArray = new Uint8Array(analyserNode.frequencyBinCount);
        let isSpeaking = false;
        let silenceStartTime = null;
        const SILENCE_THRESHOLD = 30; // Volume threshold (0-255)
        const SILENCE_DURATION = 2000; // 2 seconds of silence to stop
        let lastCheckTime = Date.now();
        
        const checkVolume = () => {
          if (!isRecording || !isHandsFree) {
            if (silenceDetectionInterval) {
              clearInterval(silenceDetectionInterval);
              silenceDetectionInterval = null;
            }
            return;
          }
          
          analyserNode.getByteFrequencyData(dataArray);
          
          // Calculate average volume
          let sum = 0;
          for (let i = 0; i < dataArray.length; i++) {
            sum += dataArray[i];
          }
          const averageVolume = sum / dataArray.length;
          
          const now = Date.now();
          
          if (averageVolume > SILENCE_THRESHOLD) {
            // User is speaking
            if (!isSpeaking) {
              isSpeaking = true;
              silenceStartTime = null;
            }
          } else {
            // Silence detected
            if (isSpeaking) {
              // User was speaking, now silence
              if (silenceStartTime === null) {
                // First moment of silence detected - mark this as speech end time
                silenceStartTime = now;
                voiceLatencyTracker.markPatientSpeechEnd();
              } else if (now - silenceStartTime >= SILENCE_DURATION) {
                // Silence for long enough - stop recording
                isSpeaking = false;
                silenceStartTime = null;
                stopRecording();
                return;
              }
            }
          }
          
          lastCheckTime = now;
        };
        
        // Check volume every 100ms
        silenceDetectionInterval = setInterval(checkVolume, 100);
      } catch (error) {
        console.error('[ERROR] Silence detection error:', error);
        // Continue without silence detection if it fails
      }
    }

    // Stop silence detection
    function stopSilenceDetection() {
      if (silenceDetectionInterval) {
        clearInterval(silenceDetectionInterval);
        silenceDetectionInterval = null;
      }
      
      if (audioContext) {
        try {
          audioContext.close();
        } catch (e) {
          // Ignore errors when closing
        }
        audioContext = null;
      }
      
      analyserNode = null;
    }

    // Start recording
    async function startRecording() {
      if (!voiceEnabled || isRecording || isSpeaking) return;
      
      // Cancel previous tracking if exists (new recording starting before bot spoke)
      voiceLatencyTracker.cancel();
      
      // Check if getUserMedia is available
      if (!isGetUserMediaAvailable()) {
        console.error('[ERROR] getUserMedia is not supported');
        alert('Voice recording is not supported in this browser.');
        return;
      }
      
      try {
        const stream = await getUserMedia({ audio: true });
        
        // Create MediaRecorder
        mediaRecorder = new MediaRecorder(stream, {
          mimeType: 'audio/webm;codecs=opus'
        });
        
        audioChunks = [];
        
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
          }
        };
        
        mediaRecorder.onstop = async () => {
          // In hands-free mode, speech end time was already marked by silence detection
          // In normal mode (push-to-talk), mark it now
          if (!isHandsFree) {
            voiceLatencyTracker.markPatientSpeechEnd();
          }
          
          // Stop silence detection
          stopSilenceDetection();
          
          // Create audio blob
          const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
          
          // Stop all tracks
          stream.getTracks().forEach(track => track.stop());
          
          // Send for transcription
          await transcribeAudio(audioBlob);
        };
        
        // Start recording
        mediaRecorder.start();
        isRecording = true;
        
        // Update UI
        if (isHandsFree) {
          micBtn.classList.add('recording');
          voiceStatus.textContent = 'üé§ Listening...';
        } else {
          micBtn.classList.add('recording');
          voiceStatus.textContent = 'üî¥ Recording...';
        }
        voiceStatus.classList.add('show', 'recording');
        
        // Start silence detection if in hands-free mode
        if (isHandsFree) {
          startSilenceDetection(stream);
        }
        
        // Auto-stop after 60 seconds (safety limit)
        setTimeout(() => {
          if (isRecording) {
            stopRecording();
          }
        }, 60000);
        
      } catch (error) {
        console.error('[ERROR] Recording error:', error);
        alert('Error accessing microphone. Please check permissions.');
        isRecording = false;
        stopSilenceDetection();
      }
    }
    
    // Stop recording
    function stopRecording() {
      if (!isRecording || !mediaRecorder) return;
      
      try {
        // In normal mode (push-to-talk), mark speech end when button is released
        // In hands-free mode, this was already marked by silence detection
        if (!isHandsFree && !voiceLatencyTracker.isTracking) {
          voiceLatencyTracker.markPatientSpeechEnd();
        }
        
        // Stop silence detection
        stopSilenceDetection();
        
        mediaRecorder.stop();
        isRecording = false;
        
        // Update UI
        micBtn.classList.remove('recording');
        voiceStatus.textContent = '‚è≥ Transcribing...';
        voiceStatus.classList.remove('recording');
        voiceStatus.classList.add('transcribing');
      } catch (error) {
        console.error('[ERROR] Stop recording error:', error);
        stopSilenceDetection();
      }
    }
    
    // Transcribe audio
    async function transcribeAudio(audioBlob) {
      const startTime = performance.now();
      console.log('[STEP] Converting Speech to Text...');
      
      try {
        voiceStatus.textContent = '‚è≥ Transcribing...';
        voiceStatus.classList.add('show', 'transcribing');
        
        const formData = new FormData();
        formData.append('audio', audioBlob, 'recording.webm');
        formData.append('session_id', sessionId);
        
        const response = await fetch(`${getApiBase()}/voice/transcribe`, {
          method: 'POST',
          body: formData
        });
        
        if (!response.ok) {
          throw new Error(`Transcription failed: ${response.status}`);
        }
        
        const data = await response.json();
        const transcribedText = data.text;
        
        // Hide status
        voiceStatus.classList.remove('show', 'transcribing');
        
        logTiming('Speech to Text', startTime);
        
        // In hands-free mode, auto-send if text is valid
        if (isHandsFree && transcribedText && transcribedText.trim().length > 0) {
          // Minimum length check to avoid sending noise
          if (transcribedText.trim().length >= 2) {
            // Auto-send the transcribed text
            input.value = transcribedText;
            await sendMessage();
          } else {
            // Text too short, just put it in input for user to see
            input.value = transcribedText;
            input.focus();
            // Restart recording in hands-free mode
            if (voiceEnabled && isHandsFree && !isSpeaking) {
              setTimeout(() => startRecording(), 500);
            }
          }
        } else {
          // Normal mode - put transcribed text in input box for user to review/edit
          input.value = transcribedText;
          input.focus();
        }
        
      } catch (error) {
        logTiming('Speech to Text (FAILED)', startTime);
        console.error('[ERROR] Transcription error:', error);
        // Cancel latency tracking on transcription failure
        voiceLatencyTracker.cancel();
        voiceStatus.textContent = '‚ùå Transcription failed';
        voiceStatus.classList.add('show');
        setTimeout(() => {
          voiceStatus.classList.remove('show');
        }, 3000);
        alert('Transcription failed. Please try again or type your message.');
      }
    }
    
    // Strip markdown formatting for TTS (convert to plain text)
    function stripMarkdownForTTS(text) {
      if (!text) return '';
      
      // First, try to extract plain text if it's HTML
      let plainText = text;
      
      // Check if text contains HTML tags
      if (text.includes('<') && text.includes('>')) {
        // If text contains HTML tags (from markdown rendering), extract text content
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = text;
        plainText = tempDiv.textContent || tempDiv.innerText || text;
      }
      
      // Remove markdown formatting patterns (but preserve the text content)
      plainText = plainText
        // Remove horizontal rules (entire lines)
        .replace(/^---+$/gm, '')
        // Remove markdown headers (# ## ###) - but keep the text after
        .replace(/^#{1,6}\s+/gm, '')
        // Remove bold/italic markers (keep content)
        .replace(/\*\*([^*]+)\*\*/g, '$1')
        .replace(/\*([^*]+)\*/g, '$1')
        .replace(/__([^_]+)__/g, '$1')
        .replace(/_([^_]+)_/g, '$1')
        // Remove code blocks (entire blocks)
        .replace(/```[\s\S]*?```/g, '')
        .replace(/`([^`]+)`/g, '$1')
        // Remove links [text](url) -> text
        .replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1')
        // Remove images ![alt](url) -> alt
        .replace(/!\[([^\]]*)\]\([^\)]+\)/g, '$1')
        // Clean up list markers (convert to natural speech)
        .replace(/^[\s]*[-*+]\s+/gm, '')
        .replace(/^\d+\.\s+/gm, '');
      
      // Convert common markdown patterns to natural speech
      plainText = plainText.replace(/\*\*([^*:]+):\*\*/g, '$1:');
      
      // Clean up whitespace (but preserve word boundaries)
      plainText = plainText
        .replace(/\n{3,}/g, '\n\n')  // Multiple newlines to double
        .replace(/[ \t]+/g, ' ')      // Multiple spaces to single
        .trim();                       // Trim start/end
      
      // Add pauses for better speech flow (after cleaning)
      plainText = plainText
        .replace(/\n\n/g, '. ')
        .replace(/\n/g, '. ')
        .replace(/\.\s*\./g, '.')
        .replace(/\s+/g, ' ')
        .trim();
      
      // Ensure we have text and it starts properly
      if (!plainText || plainText.length === 0) {
        return '';
      }
      
      // Final cleanup: ensure first character is not a space or punctuation (unless intentional)
      // This helps prevent TTS from skipping the first word
      plainText = plainText.replace(/^[\s\.]+/, '').trim();
      
      return plainText;
    }
    
    // Text-to-speech for bot responses - Using Browser Web Speech API
    async function speakText(text) {
      if (!voiceEnabled || isSpeaking) {
        return;
      }
      
      // Check if browser supports Speech Synthesis
      if (!('speechSynthesis' in window)) {
        console.error('[ERROR] Browser does not support Speech Synthesis');
        return;
      }
      
      const startTime = performance.now();
      console.log('[STEP] Converting Text to Speech...');
      
      try {
        // Strip markdown formatting before speaking
        const plainText = stripMarkdownForTTS(text);
        
        if (!plainText || plainText.trim().length === 0) {
          return;
        }
        
        // Cancel any ongoing speech first to prevent conflicts
        speechSynthesis.cancel();
        
        // Wait longer to ensure cancellation is fully processed
        // This prevents the TTS engine from skipping the first word
        await new Promise(resolve => setTimeout(resolve, 200));
        
        isSpeaking = true;
        
        // Disable mic while bot is speaking
        micBtn.classList.add('disabled');
        voiceStatus.textContent = 'üîä Bot speaking...';
        voiceStatus.classList.add('show', 'speaking');
        
        // Ensure voices are loaded (some browsers load them asynchronously)
        let voices = speechSynthesis.getVoices();
        if (voices.length === 0) {
          // Wait for voices to load
          await new Promise(resolve => {
            const checkVoices = () => {
              voices = speechSynthesis.getVoices();
              if (voices.length > 0) {
                resolve();
              } else {
                // Some browsers fire voiceschanged event
                speechSynthesis.onvoiceschanged = () => {
                  voices = speechSynthesis.getVoices();
                  if (voices.length > 0) {
                    speechSynthesis.onvoiceschanged = null;
                    resolve();
                  }
                };
                // Fallback timeout
                setTimeout(resolve, 500);
              }
            };
            checkVoices();
          });
          voices = speechSynthesis.getVoices();
        }
        
        // Create speech utterance with plain text (no markdown)
        const utterance = new SpeechSynthesisUtterance(plainText);
        utterance.rate = 1.0;  // Normal speed
        utterance.pitch = 1.0;  // Normal pitch
        utterance.volume = 1.0;  // Full volume
        utterance.lang = 'en-US';
        
        // Try to get a good voice
        if (voices.length > 0) {
          // Prefer female voice or clear voice
          const preferredVoice = voices.find(v => 
            v.lang.startsWith('en') && (
              v.name.includes('Female') || 
              v.name.includes('Zira') || 
              v.name.includes('Google US English Female')
            )
          ) || voices.find(v => v.lang.startsWith('en'));
          
          if (preferredVoice) {
            utterance.voice = preferredVoice;
          }
        }
        
        // Set up event handlers BEFORE calling speak()
        utterance.onstart = () => {
          // Mark bot voice start timestamp and calculate latency
          voiceLatencyTracker.markBotVoiceStart();
          
          // TTS started speaking (playback begins)
        };
        
        utterance.onend = () => {
          // Speech playback completed (not logging timing here - only processing time matters)
          stopSpeaking();
          
          // In hands-free mode, auto-start recording after bot finishes speaking
          if (voiceEnabled && isHandsFree) {
            micBtn.classList.remove('disabled');
            // Wait a bit before starting to record (let TTS finish completely)
            setTimeout(() => {
              if (voiceEnabled && isHandsFree && !isSpeaking && !isRecording) {
                startRecording();
              }
            }, 500);
          } else if (voiceEnabled) {
            // Normal mode - just show status
            micBtn.classList.remove('disabled');
            voiceStatus.textContent = 'üé§ Your turn';
            voiceStatus.classList.add('show');
            setTimeout(() => {
              voiceStatus.classList.remove('show');
            }, 2000);
          }
        };
        
        utterance.onerror = (error) => {
          logTiming('Text to Speech (FAILED)', startTime);
          console.error('[ERROR] Speech synthesis error:', error);
          // Cancel latency tracking on TTS failure
          voiceLatencyTracker.cancel();
          stopSpeaking();
        };
        
        // Verify utterance text is correct before speaking
        if (utterance.text !== plainText) {
          utterance.text = plainText;
        }
        
        // Longer delay to ensure utterance is fully configured and TTS engine is ready
        // This helps prevent the first word from being skipped
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Double-check text is still correct
        if (utterance.text !== plainText) {
          utterance.text = plainText;
        }
        
        // Speak the text - processing is complete at this point
        speechSynthesis.speak(utterance);
        
        // Log timing immediately after speak() is called (processing time only, not playback)
        logTiming('Text to Speech', startTime);
        
      } catch (error) {
        logTiming('Text to Speech (FAILED)', startTime);
        console.error('[ERROR] TTS error:', error);
        // Cancel latency tracking on TTS failure
        voiceLatencyTracker.cancel();
        stopSpeaking();
      }
    }
    
    // Stop speaking
    function stopSpeaking() {
      if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
      }
      
      isSpeaking = false;
      voiceStatus.classList.remove('show', 'speaking');
      
      if (voiceEnabled && !isRecording) {
        micBtn.classList.remove('disabled');
      }
    }
    
    // Mic button event listeners - only for push-to-talk mode (not hands-free)
    micBtn.addEventListener('mousedown', () => {
      if (!isHandsFree && voiceEnabled) {
        startRecording();
      }
    });
    micBtn.addEventListener('mouseup', () => {
      if (!isHandsFree && voiceEnabled) {
        stopRecording();
      }
    });
    micBtn.addEventListener('mouseleave', () => {
      if (!isHandsFree && isRecording) {
        stopRecording();
      }
    });
    
    // Touch support for mobile
    micBtn.addEventListener('touchstart', (e) => {
      if (!isHandsFree && voiceEnabled) {
        e.preventDefault();
        startRecording();
      }
    });
    micBtn.addEventListener('touchend', (e) => {
      if (!isHandsFree && voiceEnabled) {
        e.preventDefault();
        stopRecording();
      }
    });
    
    // Voice toggle button
    voiceToggleBtn.addEventListener('click', toggleVoiceMode);

    // ===== MODEL SELECTOR FUNCTIONALITY =====

    let availableModels = {};
    let activeModelId = null;

    // Model selector elements
    const modelSelector = document.getElementById('modelSelector');
    const modelSelectBtn = document.getElementById('modelSelectBtn');
    const modelDropdown = document.getElementById('modelDropdown');
    const activeModelName = document.getElementById('activeModelName');

    // Load available models
    async function loadAvailableModels() {
      try {
        const response = await fetch(`${getApiBase()}/models`);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const data = await response.json();
        availableModels = data.models || {};
        activeModelId = data.active_model;

        updateModelDropdown();
        updateActiveModelDisplay();
      } catch (error) {
        console.error('[MODEL] Failed to load models:', error);
        activeModelName.textContent = 'Error loading models';
      }
    }

    // Update the dropdown with available models
    function updateModelDropdown() {
      if (!modelDropdown) return;

      const modelIds = Object.keys(availableModels);
      if (modelIds.length === 0) {
        modelDropdown.innerHTML = `
          <div class="model-option">
            <div class="model-info">
              <div class="model-name">No models available</div>
              <div class="model-provider">Check configuration</div>
            </div>
          </div>
        `;
        return;
      }

      modelDropdown.innerHTML = modelIds.map(modelId => {
        const model = availableModels[modelId];
        const isActive = modelId === activeModelId;
        return `
          <div class="model-option ${isActive ? 'active' : ''}" data-model="${modelId}">
            <div class="model-info">
              <div class="model-name">${model.display_name}</div>
              <div class="model-provider">${model.provider}</div>
            </div>
            ${isActive ? '<div class="model-status">Active</div>' : ''}
          </div>
        `;
      }).join('');

      // Add event listeners to model options
      document.querySelectorAll('.model-option').forEach(option => {
        option.addEventListener('click', () => {
          const modelId = option.dataset.model;
          if (modelId && modelId !== 'loading') {
            selectModel(modelId);
          }
        });
      });
    }

    // Update the active model display
    function updateActiveModelDisplay() {
      if (!activeModelName) return;

      if (activeModelId && availableModels[activeModelId]) {
        const model = availableModels[activeModelId];
        activeModelName.textContent = model.display_name.split(' ')[0]; // Show first word (e.g., "GPT-4o")
      } else {
        activeModelName.textContent = 'No model';
      }
    }

    // Select a model
    async function selectModel(modelId) {
      if (!modelId || modelId === activeModelId) return;

      try {
        const response = await fetch(`${getApiBase()}/models/active`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ model_id: modelId })
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();
        if (data.success) {
          activeModelId = modelId;
          updateModelDropdown();
          updateActiveModelDisplay();
          closeModelDropdown();

          // Show success message
          showToast(`Model switched to ${availableModels[modelId].display_name}`, 'success');
        } else {
          throw new Error(data.error || 'Failed to switch model');
        }
      } catch (error) {
        console.error('[MODEL] Failed to switch model:', error);
        showToast(`Failed to switch model: ${error.message}`, 'error');
      }
    }

    // Toggle dropdown visibility
    function toggleModelDropdown() {
      if (!modelSelector) return;

      const isOpen = modelSelector.classList.contains('open');
      if (isOpen) {
        closeModelDropdown();
      } else {
        openModelDropdown();
      }
    }

    function openModelDropdown() {
      if (!modelSelector || !modelDropdown) return;
      modelSelector.classList.add('open');
      modelDropdown.classList.add('show');
    }

    function closeModelDropdown() {
      if (!modelSelector || !modelDropdown) return;
      modelSelector.classList.remove('open');
      modelDropdown.classList.remove('show');
    }

    // Event listeners for model selector
    if (modelSelectBtn) {
      modelSelectBtn.addEventListener('click', toggleModelDropdown);
    }

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!modelSelector?.contains(e.target)) {
        closeModelDropdown();
      }
    });

    // Load models on page load
    loadAvailableModels();

    // ===== TOAST NOTIFICATIONS =====

    function showToast(message, type = 'info') {
      // Remove existing toasts
      const existingToasts = document.querySelectorAll('.toast-notification');
      existingToasts.forEach(toast => toast.remove());

      // Create toast element
      const toast = document.createElement('div');
      toast.className = `toast-notification toast-${type}`;
      toast.innerHTML = `
        <div class="toast-content">
          <span class="toast-message">${message}</span>
          <button class="toast-close" onclick="this.parentElement.parentElement.remove()">√ó</button>
        </div>
      `;

      // Add to page
      document.body.appendChild(toast);

      // Auto-remove after 5 seconds
      setTimeout(() => {
        if (toast.parentElement) {
          toast.remove();
        }
      }, 5000);
    }
    
    // Modal event handlers - attach after DOM is ready
    function setupModalHandlers() {
      const continueHandsFreeBtn = document.getElementById('continueHandsFreeBtn');
      const switchToChatBtn = document.getElementById('switchToChatBtn');
      const handsFreeModal = document.getElementById('handsFreeModal');

      console.log('[MODAL] Setting up handlers:', {
        continueBtn: !!continueHandsFreeBtn,
        switchBtn: !!switchToChatBtn,
        modal: !!handsFreeModal
      });

      if (continueHandsFreeBtn) {
        continueHandsFreeBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log('[MODAL] Continue button clicked');
          enableHandsFreeMode();
        });
      } else {
        console.error('[MODAL] Continue button not found!');
      }

      if (switchToChatBtn) {
        switchToChatBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log('[MODAL] Switch to Chat button clicked');
          hideHandsFreeModal();
          // Disable voice mode completely
          voiceEnabled = false;
          isHandsFree = false;
          
          // Update UI to reflect voice is off
          voiceToggleBtn.classList.remove('active');
          voiceToggleBtn.querySelector('span').textContent = 'Voice Off';
          micBtn.classList.add('disabled');
          micBtn.title = 'Push to talk';
          
          // Stop any ongoing recording or speaking
          stopRecording();
          stopSpeaking();
          
          // Hide voice status
          voiceStatus.classList.remove('show');
          
          // Start the session (send greeting)
          await startSessionAfterModalChoice();
        });
      } else {
        console.error('[MODAL] Switch to Chat button not found!');
      }

      // Close modal when clicking outside (but not on modal-content)
      if (handsFreeModal) {
        handsFreeModal.addEventListener('click', async (e) => {
          // Only close if clicking directly on the modal backdrop, not on modal-content
          if (e.target === handsFreeModal) {
            hideHandsFreeModal();
            // Disable voice mode completely
            voiceEnabled = false;
            isHandsFree = false;
            
            // Update UI to reflect voice is off
            voiceToggleBtn.classList.remove('active');
            voiceToggleBtn.querySelector('span').textContent = 'Voice Off';
            micBtn.classList.add('disabled');
            micBtn.title = 'Push to talk';
            
            // Stop any ongoing recording or speaking
            stopRecording();
            stopSpeaking();
            
            // Hide voice status
            voiceStatus.classList.remove('show');
            
            // Start the session (send greeting) when clicking outside
            await startSessionAfterModalChoice();
          }
        });
        
        // Prevent modal-content clicks from closing the modal
        const modalContent = handsFreeModal.querySelector('.modal-content');
        if (modalContent) {
          modalContent.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent click from bubbling to modal backdrop
          });
        }
      }
    }
    
    // Call setup function when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setupModalHandlers);
    } else {
      // DOM is already ready
      setupModalHandlers();
    }
    
    // Check voice availability on page load
    checkVoiceAvailability();
    
    // ===== END VOICE FUNCTIONALITY =====

    // ===== EVALUATION TOGGLE FUNCTIONALITY =====
    
    // Toggle evaluation functionality
    async function toggleEvaluations() {
      const toggle = document.getElementById('evaluationToggle');
      const status = document.getElementById('evaluationStatus');
      const latencySpan = document.getElementById('evaluationLatency');
      
      const enabled = toggle.checked;
      
      try {
        const response = await fetch('/evaluation/toggle', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            session_id: sessionId,
            enabled: enabled
          })
        });
        
        const data = await response.json();
        
        if (data.success) {
          status.textContent = enabled ? 'Enabled' : 'Disabled';
          status.style.color = enabled ? '#4CAF50' : '#666';
          latencySpan.textContent = enabled ? '(+5-7 seconds per response)' : '(Fast mode)';
          
          console.log(`[EVALUATIONS] ${enabled ? 'Enabled' : 'Disabled'} for session ${sessionId}`);
        }
      } catch (error) {
        console.error('Failed to toggle evaluations:', error);
        toggle.checked = !enabled; // Revert on error
      }
    }
    
    // Load evaluation status on page load
    async function loadEvaluationStatus() {
      try {
        const response = await fetch(`/evaluation/status?session_id=${sessionId}`);
        const data = await response.json();
        
        const toggle = document.getElementById('evaluationToggle');
        const status = document.getElementById('evaluationStatus');
        const latencySpan = document.getElementById('evaluationLatency');
        
        if (toggle && status && latencySpan) {
          toggle.checked = data.evaluations_enabled;
          status.textContent = data.evaluations_enabled ? 'Enabled' : 'Disabled';
          status.style.color = data.evaluations_enabled ? '#4CAF50' : '#666';
          
          if (data.evaluations_enabled) {
            latencySpan.textContent = '(+5-7 seconds per response)';
          } else {
            latencySpan.textContent = '(Fast mode)';
          }
        }
      } catch (error) {
        console.error('Failed to load evaluation status:', error);
      }
    }
    
    // Load evaluation status when page loads
    loadEvaluationStatus();
    
    // ===== END EVALUATION TOGGLE FUNCTIONALITY =====

    // Add a function to start a new conversation (clear memory)
    async function startNewConversation() {
      // Starting new chat
      
      // Create new session for new conversation
      const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
      const timestamp = new Date().getTime().toString().slice(-6);
      const randomId = Math.random().toString(36).substr(2, 6);
      sessionId = `cf.conversation.${date}.${timestamp}${randomId}`;
      localStorage.setItem('chatbot_session_id', sessionId);
      messagesDiv.innerHTML = '';
      // Messages cleared
      
      // Reset greeting flag for new conversation
      greetingSent = false;
      
      // Send initial greeting from bot
      sendInitialGreeting();
    }
    
    // Function to send initial greeting message from bot
    // This gets the initial greeting directly from the backend following the system prompt
    async function sendInitialGreeting() {
      // Prevent duplicate greetings
      if (greetingSent) {
        return;
      }
      
      // Check if there are already messages (including bot messages)
      if (messagesDiv.children.length > 0) {
        greetingSent = true;
        return;
      }
      
      // Check if there are any user messages (conversation has started)
      const userMessages = messagesDiv.querySelectorAll('.message.user');
      if (userMessages.length > 0) {
        greetingSent = true;
        return;
      }
      
      greetingSent = true;
      
      const startTime = performance.now();
      console.log('[STEP] Generating Initial Greeting...');
      
      // Show thinking animation
      const botDiv = addMessageHTML("", "bot");
      botDiv.innerHTML = `
        <div class="thinking">
          Thinking
          <span class="thinking-dots">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
      `;
      
      // Force scroll to ensure thinking is visible
      setTimeout(() => scrollToBottom(), 50);
      
      // Start streaming - enable scroll tracking
      isStreaming = true;
      scrollMode = 'auto';
      updateButtonVisibility();
      
      try {
        const response = await fetch(`${getApiBase()}/chat/greeting`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            session_id: sessionId
          })
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        // Keep thinking animation until we get thinking_complete signal
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        let fullResponse = "";
        let lastRenderTime = 0;
        const renderThrottle = 16; // 60fps - re-render every 16ms for smooth streaming
        
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || ""; // Keep incomplete line in buffer
          
          for (const line of lines) {
            if (line.startsWith('data: ')) {
              try {
                const data = JSON.parse(line.slice(6));
                
                if (data.type === 'thinking_complete') {
                  // Clear thinking animation and prepare for streaming
                  botDiv.innerHTML = `<div class="message-content"></div>`;
                } else if (data.type === 'token') {
                  // Add token to response
                  const token = data.token;
                  fullResponse += token;
                  
                  // Throttle rendering to improve performance
                  const now = Date.now();
                  if (now - lastRenderTime > renderThrottle) {
                    // Render markdown and update only the message content
                    const contentDiv = botDiv.querySelector('.message-content');
                    if (contentDiv) {
                      contentDiv.innerHTML = renderMarkdown(fullResponse);
                    } else {
                      // Fallback: create content div only
                      botDiv.innerHTML = `<div class="message-content">${renderMarkdown(fullResponse)}</div>`;
                    }
                    scrollToBottom();
                    lastRenderTime = now;
                  }
                } else if (data.type === 'done') {
                  // Final response received
                  fullResponse = data.full_response || fullResponse;
                  
                  // Log timing for greeting generation
                  logTiming('Initial Greeting Generation', startTime);
                  
                  // Check if response is empty
                  if (!fullResponse || fullResponse.trim() === '') {
                    console.error("[ERROR] Empty greeting received!");
                    fullResponse = "Hello! I'm HealthYoda, your medical intake assistant. What brings you in today?";
                  }
                  
                  // Final render with complete response and buttons
                  botDiv.innerHTML = `
                    <div class="message-content">${renderMarkdown(fullResponse)}</div>
                    <div class="feedback-buttons">
                      <button class="copy-button" onclick="copyMessage(this)" title="Copy message">
                        üìã
                      </button>
                      <button class="feedback-btn thumbs-up" onclick="submitFeedback(this, 'thumbs_up')" title="Good response">
                        üëç
                      </button>
                      <button class="feedback-btn thumbs-down" onclick="submitFeedback(this, 'thumbs_down')" title="Bad response">
                        üëé
                      </button>
                      <span class="feedback-text"></span>
                    </div>
                  `;
                  
                  scrollToBottom();
                  isStreaming = false;
                } else if (data.type === 'error') {
                  throw new Error(data.error || 'Unknown error');
                }
              } catch (parseError) {
                console.error('[ERROR] Error parsing greeting stream data:', parseError);
              }
            }
          }
        }
      } catch (error) {
        logTiming('Initial Greeting Generation (FAILED)', startTime);
        console.error('[ERROR] Error getting greeting:', error);
        // Remove thinking animation and reset flag
        if (botDiv && botDiv.parentNode) {
          botDiv.remove();
        }
        greetingSent = false;
        isStreaming = false;
        // Fallback: send a message to trigger the bot
        await sendMessageText("start");
      }
    }

    // Variables for undo functionality
    let chatBackup = null;
    let undoTimeout = null;
    let isUndoMode = false;

    // Handle new chat button click
    async function handleNewChat() {
      const button = document.getElementById('newChatBtn');
      
      if (!isUndoMode) {
        // Store current chat before clearing
        chatBackup = {
          messages: Array.from(messagesDiv.children).map(msg => ({
            className: msg.className,
            innerHTML: msg.innerHTML
          })),
          sessionId: sessionId
        };
        
        // Clear the messages display
        // Clearing messages for undo
        messagesDiv.innerHTML = '';
        
        // Change button to undo mode
        button.innerHTML = '<span><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M2.6687 11.333V8.66699C2.6687 7.74455 2.66841 7.01205 2.71655 6.42285C2.76533 5.82612 2.86699 5.31731 3.10425 4.85156L3.25854 4.57617C3.64272 3.94975 4.19392 3.43995 4.85229 3.10449L5.02905 3.02149C5.44666 2.84233 5.90133 2.75849 6.42358 2.71582C7.01272 2.66769 7.74445 2.66797 8.66675 2.66797H9.16675C9.53393 2.66797 9.83165 2.96586 9.83179 3.33301C9.83179 3.70028 9.53402 3.99805 9.16675 3.99805H8.66675C7.7226 3.99805 7.05438 3.99834 6.53198 4.04102C6.14611 4.07254 5.87277 4.12568 5.65601 4.20313L5.45581 4.28906C5.01645 4.51293 4.64872 4.85345 4.39233 5.27149L4.28979 5.45508C4.16388 5.7022 4.08381 6.01663 4.04175 6.53125C3.99906 7.05373 3.99878 7.7226 3.99878 8.66699V11.333C3.99878 12.2774 3.99906 12.9463 4.04175 13.4688C4.08381 13.9833 4.16389 14.2978 4.28979 14.5449L4.39233 14.7285C4.64871 15.1465 5.01648 15.4871 5.45581 15.7109L5.65601 15.7969C5.87276 15.8743 6.14614 15.9265 6.53198 15.958C7.05439 16.0007 7.72256 16.002 8.66675 16.002H11.3337C12.2779 16.002 12.9461 16.0007 13.4685 15.958C13.9829 15.916 14.2976 15.8367 14.5447 15.7109L14.7292 15.6074C15.147 15.3511 15.4879 14.9841 15.7117 14.5449L15.7976 14.3447C15.8751 14.128 15.9272 13.8546 15.9587 13.4688C16.0014 12.9463 16.0017 12.2774 16.0017 11.333V10.833C16.0018 10.466 16.2997 10.1681 16.6667 10.168C17.0339 10.168 17.3316 10.4659 17.3318 10.833V11.333C17.3318 12.2555 17.3331 12.9879 17.2849 13.5771C17.2422 14.0993 17.1584 14.5541 16.9792 14.9717L16.8962 15.1484C16.5609 15.8066 16.0507 16.3571 15.4246 16.7412L15.1492 16.8955C14.6833 17.1329 14.1739 17.2354 13.5769 17.2842C12.9878 17.3323 12.256 17.332 11.3337 17.332H8.66675C7.74446 17.332 7.01271 17.3323 6.42358 17.2842C5.90135 17.2415 5.44665 17.1577 5.02905 16.9785L4.85229 16.8955C4.19396 16.5601 3.64271 16.0502 3.25854 15.4238L3.10425 15.1484C2.86697 14.6827 2.76534 14.1739 2.71655 13.5771C2.66841 12.9879 2.6687 12.2555 2.6687 11.333ZM13.4646 3.11328C14.4201 2.334 15.8288 2.38969 16.7195 3.28027L16.8865 3.46485C17.6141 4.35685 17.6143 5.64423 16.8865 6.53613L16.7195 6.7207L11.6726 11.7686C11.1373 12.3039 10.4624 12.6746 9.72827 12.8408L9.41089 12.8994L7.59351 13.1582C7.38637 13.1877 7.17701 13.1187 7.02905 12.9707C6.88112 12.8227 6.81199 12.6134 6.84155 12.4063L7.10132 10.5898L7.15991 10.2715C7.3262 9.53749 7.69692 8.86241 8.23218 8.32715L13.2791 3.28027L13.4646 3.11328ZM15.7791 4.2207C15.3753 3.81702 14.7366 3.79124 14.3035 4.14453L14.2195 4.2207L9.17261 9.26856C8.81541 9.62578 8.56774 10.0756 8.45679 10.5654L8.41772 10.7773L8.28296 11.7158L9.22241 11.582L9.43433 11.543C9.92426 11.432 10.3749 11.1844 10.7322 10.8271L15.7791 5.78027L15.8552 5.69629C16.185 5.29194 16.1852 4.708 15.8552 4.30371L15.7791 4.2207Z"></path></svg></span><span>Undo</span><div class="countdown-container"><div class="countdown-circle" id="countdownCircle"></div></div>';
        button.classList.add('undo-mode');
        isUndoMode = true;
        
        // Initialize countdown circle
        initializeCountdownCircle();
        
        // Start countdown - this will call permanentlyDeleteChat after 3 seconds
        // The greeting will be sent AFTER the timer ends (in permanentlyDeleteChat)
        startUndoCountdown();
      } else {
        // Restore chat
        restoreChat();
      }
    }

    // Initialize countdown circle
    function initializeCountdownCircle() {
      const circle = document.getElementById('countdownCircle');
      const radius = 10; // radius of the circle (increased from 8)
      const circumference = 2 * Math.PI * radius;
      
      // Create SVG circle - start with full circle (offset = 0)
      circle.innerHTML = `
        <svg width="24" height="24">
          <circle class="progress-ring progress-ring-bg" cx="12" cy="12" r="${radius}"></circle>
          <circle class="progress-ring progress-ring-fill" cx="12" cy="12" r="${radius}" 
                  stroke-dasharray="${circumference}" 
                  stroke-dashoffset="0"></circle>
        </svg>
        <span class="countdown-text" id="countdownText">3</span>
      `;
      
      // Store circumference for animation
      circle.dataset.circumference = circumference;
    }

    // Start undo countdown
    function startUndoCountdown() {
      const textElement = document.getElementById('countdownText');
      const circle = document.getElementById('countdownCircle');
      const circumference = parseFloat(circle.dataset.circumference);
      
      const startTime = Date.now();
      const duration = 3000; // 3 seconds in milliseconds
      
      const updateCountdown = () => {
        const elapsed = Date.now() - startTime;
        const remaining = Math.max(0, duration - elapsed);
        const countdown = Math.ceil(remaining / 1000);
        
        // Update text (always white)
        textElement.textContent = countdown;
        textElement.style.color = 'white';
        
        // Update circle progress - smooth animation
        const progress = remaining / duration; // This goes from 1.0 to 0.0
        const offset = circumference - (progress * circumference);
        const fillCircle = circle.querySelector('.progress-ring-fill');
        fillCircle.style.strokeDashoffset = offset;
        
        // Keep circle white always
        fillCircle.style.stroke = '#fff';
        
        if (remaining > 0) {
          undoTimeout = requestAnimationFrame(updateCountdown);
        } else {
          // Time's up - permanently delete chat
          permanentlyDeleteChat();
        }
      };
      
      updateCountdown();
    }

    // Restore chat from backup
    function restoreChat() {
      if (chatBackup) {
        // Restore messages
        messagesDiv.innerHTML = '';
        chatBackup.messages.forEach(msgData => {
          const msgDiv = document.createElement('div');
          msgDiv.className = msgData.className;
          msgDiv.innerHTML = msgData.innerHTML;
          messagesDiv.appendChild(msgDiv);
        });
        
        // Add copy buttons to any bot messages that don't have them
        const botMessages = messagesDiv.querySelectorAll('.message.bot');
        botMessages.forEach(msgDiv => {
          if (!msgDiv.querySelector('.copy-button')) {
            const textContent = msgDiv.textContent || msgDiv.innerText || '';
            if (textContent.trim()) {
              msgDiv.innerHTML = `
                <div class="message-content">${msgDiv.innerHTML}</div>
                <button class="copy-button" onclick="copyMessage(this)" title="Copy message">
                  üìã
                </button>
              `;
            }
          }
        });
        
        // Restore session
        sessionId = chatBackup.sessionId;
        localStorage.setItem('chatbot_session_id', sessionId);
        
        // Reset greeting flag since we're restoring old chat
        greetingSent = true; // Set to true since we have messages
        
        // Scroll to bottom after restoring messages
        scrollToBottom();
        
        // Clear backup
        chatBackup = null;
      }
      
      // Reset button
      resetNewChatButton();
    }

    // Permanently delete chat
    async function permanentlyDeleteChat() {
      // Create new session for new conversation
      const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
      const timestamp = new Date().getTime().toString().slice(-6);
      const randomId = Math.random().toString(36).substr(2, 6);
      sessionId = `cf.conversation.${date}.${timestamp}${randomId}`;
      localStorage.setItem('chatbot_session_id', sessionId);
      
      // Clear messages display
      messagesDiv.innerHTML = '';
      
      // Clear backup
      chatBackup = null;
      
      // Reset button
      resetNewChatButton();
      
      // Reset greeting flag for new conversation
      greetingSent = false;
      
      // Reset voice mode state for new chat
      voiceEnabled = false;
      isHandsFree = false;
      voiceToggleBtn.classList.remove('active');
      voiceToggleBtn.querySelector('span').textContent = 'Voice Off';
      micBtn.classList.add('disabled');
      micBtn.title = 'Push to talk';
      stopRecording();
      stopSpeaking();
      
      // Show voice warning modal for new chat
      // The greeting will be sent after user chooses an option in the modal
      showHandsFreeModal();
    }

    // Reset new chat button to normal state
    function resetNewChatButton() {
      const button = document.getElementById('newChatBtn');
      button.innerHTML = '<span><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M2.6687 11.333V8.66699C2.6687 7.74455 2.66841 7.01205 2.71655 6.42285C2.76533 5.82612 2.86699 5.31731 3.10425 4.85156L3.25854 4.57617C3.64272 3.94975 4.19392 3.43995 4.85229 3.10449L5.02905 3.02149C5.44666 2.84233 5.90133 2.75849 6.42358 2.71582C7.01272 2.66769 7.74445 2.66797 8.66675 2.66797H9.16675C9.53393 2.66797 9.83165 2.96586 9.83179 3.33301C9.83179 3.70028 9.53402 3.99805 9.16675 3.99805H8.66675C7.7226 3.99805 7.05438 3.99834 6.53198 4.04102C6.14611 4.07254 5.87277 4.12568 5.65601 4.20313L5.45581 4.28906C5.01645 4.51293 4.64872 4.85345 4.39233 5.27149L4.28979 5.45508C4.16388 5.7022 4.08381 6.01663 4.04175 6.53125C3.99906 7.05373 3.99878 7.7226 3.99878 8.66699V11.333C3.99878 12.2774 3.99906 12.9463 4.04175 13.4688C4.08381 13.9833 4.16389 14.2978 4.28979 14.5449L4.39233 14.7285C4.64871 15.1465 5.01648 15.4871 5.45581 15.7109L5.65601 15.7969C5.87276 15.8743 6.14614 15.9265 6.53198 15.958C7.05439 16.0007 7.72256 16.002 8.66675 16.002H11.3337C12.2779 16.002 12.9461 16.0007 13.4685 15.958C13.9829 15.916 14.2976 15.8367 14.5447 15.7109L14.7292 15.6074C15.147 15.3511 15.4879 14.9841 15.7117 14.5449L15.7976 14.3447C15.8751 14.128 15.9272 13.8546 15.9587 13.4688C16.0014 12.9463 16.0017 12.2774 16.0017 11.333V10.833C16.0018 10.466 16.2997 10.1681 16.6667 10.168C17.0339 10.168 17.3316 10.4659 17.3318 10.833V11.333C17.3318 12.2555 17.3331 12.9879 17.2849 13.5771C17.2422 14.0993 17.1584 14.5541 16.9792 14.9717L16.8962 15.1484C16.5609 15.8066 16.0507 16.3571 15.4246 16.7412L15.1492 16.8955C14.6833 17.1329 14.1739 17.2354 13.5769 17.2842C12.9878 17.3323 12.256 17.332 11.3337 17.332H8.66675C7.74446 17.332 7.01271 17.3323 6.42358 17.2842C5.90135 17.2415 5.44665 17.1577 5.02905 16.9785L4.85229 16.8955C4.19396 16.5601 3.64271 16.0502 3.25854 15.4238L3.10425 15.1484C2.86697 14.6827 2.76534 14.1739 2.71655 13.5771C2.66841 12.9879 2.6687 12.2555 2.6687 11.333ZM13.4646 3.11328C14.4201 2.334 15.8288 2.38969 16.7195 3.28027L16.8865 3.46485C17.6141 4.35685 17.6143 5.64423 16.8865 6.53613L16.7195 6.7207L11.6726 11.7686C11.1373 12.3039 10.4624 12.6746 9.72827 12.8408L9.41089 12.8994L7.59351 13.1582C7.38637 13.1877 7.17701 13.1187 7.02905 12.9707C6.88112 12.8227 6.81199 12.6134 6.84155 12.4063L7.10132 10.5898L7.15991 10.2715C7.3262 9.53749 7.69692 8.86241 8.23218 8.32715L13.2791 3.28027L13.4646 3.11328ZM15.7791 4.2207C15.3753 3.81702 14.7366 3.79124 14.3035 4.14453L14.2195 4.2207L9.17261 9.26856C8.81541 9.62578 8.56774 10.0756 8.45679 10.5654L8.41772 10.7773L8.28296 11.7158L9.22241 11.582L9.43433 11.543C9.92426 11.432 10.3749 11.1844 10.7322 10.8271L15.7791 5.78027L15.8552 5.69629C16.185 5.29194 16.1852 4.708 15.8552 4.30371L15.7791 4.2207Z"></path></svg></span><span>New Chat</span>';
      button.classList.remove('undo-mode');
      isUndoMode = false;
      
      if (undoTimeout) {
        cancelAnimationFrame(undoTimeout);
        undoTimeout = null;
      }
    }

    // Double-click to start new conversation removed to prevent accidental chat clearing

    // Polyfill for POST EventSource
    class EventSourcePolyfill {
      constructor(url, options) {
        const { method, headers, body } = options;
        this._url = url;
        this._method = method || "GET";
        this._headers = headers || {};
        this._body = body || null;
        this.onmessage = null;
        this.onerror = null;
        this._start();
      }

      async _start() {
        const response = await fetch(this._url, {
          method: this._method,
          headers: this._headers,
          body: this._body,
        });
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });
          const parts = buffer.split("\n\n");
          buffer = parts.pop();
          for (const part of parts) {
            if (part.startsWith("data: ")) {
              const data = part.replace("data: ", "");
              if (this.onmessage) this.onmessage({ data });
            }
          }
        }
      }

      close() {}
    }

    // Simplified user info (no authentication)
    function updateUserInfo() {
      const userName = document.getElementById('userName');
      const userAvatar = document.getElementById('userAvatar');
      const userEmail = document.getElementById('userEmail');
      
      userName.textContent = 'User';
      userAvatar.textContent = 'U';
      userEmail.textContent = 'HealthYoda User';
    }

    // Handle dropdown toggle
    function toggleDropdown() {
      const dropdown = document.getElementById('userDropdown');
      dropdown.classList.toggle('show');
    }

    // Close dropdown when clicking outside
    function closeDropdown(event) {
      const userMenu = document.getElementById('userMenu');
      const dropdown = document.getElementById('userDropdown');
      
      if (!userMenu.contains(event.target)) {
        dropdown.classList.remove('show');
      }
    }

    // Handle logout (simplified - just clear local state)
    function handleLogout() {
      // Clear session
      localStorage.removeItem('chatbot_session_id');
      messagesDiv.innerHTML = '';
      
      // Create new session
      const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
      const timestamp = new Date().getTime().toString().slice(-6);
      const randomId = Math.random().toString(36).substr(2, 6);
      sessionId = `cf.conversation.${date}.${timestamp}${randomId}`;
      localStorage.setItem('chatbot_session_id', sessionId);
      
      // Session cleared
    }

    // OLD AUTH CODE REMOVED - Handle OAuth callback
    function handleOAuthCallback_DELETED() {
      const urlParams = new URLSearchParams(window.location.search);
      const code = urlParams.get('code');
      const error = urlParams.get('error');

      if (error) {
        alert('Microsoft login failed: ' + error);
        return;
      }

      if (code) {
        exchangeCodeForToken(code);
      }
    }

    // Exchange authorization code for access token
    async function exchangeCodeForToken(code) {
      // Get code verifier from session storage
      const codeVerifier = sessionStorage.getItem('code_verifier');
      
      if (!codeVerifier) {
        /*alert('Login failed: Code verifier not found');*/
        window.location.href = "login.html";
        return;
      }
      
      try {
        const requestBody = {
          code: code,
          redirect_uri: window.location.origin + "/index.html",
          code_verifier: codeVerifier
        };
        
        const response = await fetch(`${getApiBase()}/auth/microsoft/callback`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestBody)
        });

        if (response.ok) {
          const data = await response.json();
          // User data received
          
          // Clear code verifier from session storage
          sessionStorage.removeItem('code_verifier');
          
          const user = {
            id: data.user_id,
            name: data.name,
            email: data.email,
            access_token: data.access_token,
            refresh_token: data.refresh_token
          };
          
          // User object created
          
          localStorage.setItem('user', JSON.stringify(user));
          
          // Clear URL parameters
          window.history.replaceState({}, document.title, window.location.pathname);
          
          // Initialize with new user
          currentUser = user;
          updateUserInfo(user);
          
          // Only load history if user.id is valid
          if (user.id) {
            loadUserChatHistory(user.id).catch(error => {
              console.error('[ERROR] Failed to load history:', error);
            });
          } else {
          }
          
          hideLoadingIndicator();
        } else {
          const errorText = await response.text();
          try {
            const errorJson = JSON.parse(errorText);
            if (errorJson.error === "Access denied") {
              alert('Access Denied: ' + errorJson.message);
            } else {
              alert('Login failed: ' + (errorJson.error || errorText || 'Unknown error'));
            }
          } catch (e) {
            alert('Login failed: ' + (errorText || 'Unknown error'));
          }
          hideLoadingIndicator();
          window.location.href = "login.html";
        }
        } catch (error) {
          hideLoadingIndicator();
          alert('Login failed: ' + error.message);
          window.location.href = "login.html";
        }
    }

    // Initialize authentication
    function initAuth() {
      // Check for OAuth callback first
      const urlParams = new URLSearchParams(window.location.search);
      const code = urlParams.get('code');
      
      if (code) {
        // We have an OAuth callback, handle it first
        showLoadingIndicator("Authenticating...");
        handleOAuthCallback();
        return; // Don't check for existing user, let the callback handle it
      }
      
      // Check if user is logged in (only if no OAuth callback)
      const user = JSON.parse(localStorage.getItem('user') || 'null');
      
      // User retrieved from localStorage
      
      if (!user || !user.access_token) {
        // No user found, redirecting to login
        window.location.href = "login.html";
        return;
      }

      // Verify token is still valid AND check domain
      showLoadingIndicator("Verifying access...");
      verifyToken(user.access_token).then(result => {
        if (result.isValid) {
          currentUser = user;
          updateUserInfo(user);
          // User authenticated, loading history
          
          // Always load history, even if it fails (but only if user.id exists)
          if (user.id) {
            loadUserChatHistory(user.id).catch(error => {
              console.error('[ERROR] Failed to load history, but continuing:', error);
              // If history loading fails and no messages, show modal
              setTimeout(() => {
                if (messagesDiv.children.length === 0 && !greetingSent) {
                  showHandsFreeModal();
                }
              }, 500);
            }).finally(() => {
              hideLoadingIndicator();
              // Double-check after history load completes - if still no messages, show modal
              setTimeout(() => {
                if (messagesDiv.children.length === 0 && !greetingSent) {
                  showHandsFreeModal();
                }
              }, 300);
            });
          } else {
            hideLoadingIndicator();
            // No user ID, show modal
            setTimeout(() => {
              if (messagesDiv.children.length === 0 && !greetingSent) {
                showHandsFreeModal();
              }
            }, 500);
          }
        } else {
          // Handle different failure reasons
          hideLoadingIndicator();
          
          // Clear invalid user data
          localStorage.removeItem('user');
          currentUser = null;
          
          // Redirect to login with appropriate error parameter
          if (result.reason === 'unauthorized_domain') {
            window.location.href = `login.html?error=unauthorized_domain&email=${encodeURIComponent(result.email || 'Unknown')}`;
          } else if (result.reason === 'invalid_token') {
            window.location.href = "login.html?error=session_expired";
          } else {
            // Token verification failed
            window.location.href = "login.html?error=verification_failed";
          }
        }
      }).catch(error => {
        console.error('[ERROR] Token verification failed:', error);
        hideLoadingIndicator();
        // Don't allow app access if verification fails
        localStorage.removeItem('user');
        currentUser = null;
        window.location.href = "login.html?error=verification_failed";
      });
    }

    // Verify Microsoft access token
    async function verifyToken(accessToken) {
      try {
        const response = await fetch('https://graph.microsoft.com/v1.0/me', {
          headers: {
            'Authorization': `Bearer ${accessToken}`
          }
        });
        
        if (!response.ok) {
          return { isValid: false, reason: 'invalid_token' };
        }
        
        const userInfo = await response.json();
        const userEmail = userInfo.mail || userInfo.userPrincipalName || '';
        
        return { isValid: true, email: userEmail };
      } catch (error) {
        console.error('[AUTH] Token verification failed:', error);
        return { isValid: false, reason: 'verification_failed' };
      }
    }

    // Update user info in header
    function updateUserInfo(user) {
      const userName = document.getElementById('userName');
      const userAvatar = document.getElementById('userAvatar');
      const userEmail = document.getElementById('userEmail');
      
      if (user) {
        userName.textContent = user.name || 'User';
        userAvatar.textContent = (user.name || 'U').charAt(0).toUpperCase();
        userEmail.textContent = user.email || '';
      } else {
        userName.textContent = 'User';
        userAvatar.textContent = 'U';
        userEmail.textContent = '';
      }
    }

    // Handle dropdown toggle
    function toggleDropdown() {
      const dropdown = document.getElementById('userDropdown');
      dropdown.classList.toggle('show');
    }

    // Close dropdown when clicking outside
    function closeDropdown(event) {
      const userMenu = document.getElementById('userMenu');
      const dropdown = document.getElementById('userDropdown');
      
      if (!userMenu.contains(event.target)) {
        dropdown.classList.remove('show');
      }
    }

    // Load user's chat history
    async function loadUserChatHistory(userId) {
      try {
        // Loading chat history
        
        // Reset greeting flag when loading history (will be set if history is empty)
        greetingSent = false;
        
        // Check if userId is valid
        if (!userId || userId === 'undefined' || userId === 'null') {
          console.error('[HISTORY] Invalid user ID:', userId);
          return;
        }
        
        // Get current user for auth token
        const currentUser = JSON.parse(localStorage.getItem('user') || 'null');
        if (!currentUser || !currentUser.access_token) {
          console.error('[HISTORY] User not authenticated');
          return;
        }
        
        const response = await fetch(`${getApiBase()}/chat/history/${userId}`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${currentUser.access_token}`
          }
        });
        
          if (response.ok) {
          const data = await response.json();
          const history = data.history || [];
          // History loaded
          
          // Only clear if we have history to show
          if (history.length > 0) {
            // Clear existing messages
            messagesDiv.innerHTML = '';
            
            // Load chat history
            for (const message of history) {
              const sender = message.role === 'user' ? 'user' : 'bot';
              if (sender === 'bot') {
                // Render markdown for bot messages with copy button and feedback buttons
                // Note: Historical messages won't have trace_id, so feedback won't work for them
                addMessageHTML(renderMarkdown(message.content), sender, null);
              } else {
                // Add user messages with edit button
                addMessage(message.content, sender);
              }
            }
            
            // History displayed
            // Scroll to bottom
            scrollToBottom();
          } else {
            // No history to load - show modal
            if (!greetingSent) {
              showHandsFreeModal();
            }
          }
        } else {
          console.error('[HISTORY] Failed to load, status:', response.status);
          const errorText = await response.text();
          console.error('[HISTORY] Error details:', errorText);
        }
      } catch (error) {
        console.error('[HISTORY] Failed to load chat history:', error);
        console.error('[HISTORY] Error details:', error.message, error.stack);
        // Continue with empty chat if loading fails
        // Show modal if no messages are displayed
        if (messagesDiv.children.length === 0 && !greetingSent) {
          showHandsFreeModal();
        }
      }
    }

    // Handle logout
    function handleLogout() {
      try {
        
  



        // Clear user data from localStorage
        localStorage.removeItem('user');
        currentUser = null;
        
        // Redirect to login page
        window.location.href = "login.html";
      } catch (error) {
        console.error('Logout failed:', error);
        alert('Logout failed: ' + error.message);
      }
    }

    // Initialize when page loads (no authentication)
    updateUserInfo();

    // Event listeners
    document.getElementById('newChatBtn').addEventListener('click', handleNewChat);
    document.getElementById('userMenu').addEventListener('click', toggleDropdown);
    document.getElementById('logoutBtn').addEventListener('click', handleLogout);
    document.addEventListener('click', closeDropdown);
    
    // Show voice warning modal by default on page load
    // Wait a bit to ensure DOM is ready and history is loaded
    setTimeout(() => {
      // Only show modal if there are no messages (new session or empty chat)
      if (messagesDiv.children.length === 0) {
        // Show the hands-free voice mode modal by default
        showHandsFreeModal();
      }
    }, 1500); // Wait 1.5 seconds for history to potentially load
  </script>

  <!-- Hands-free confirmation modal -->
  <div id="handsFreeModal" class="modal">
    <div class="modal-content">
      <h3>üé§ Hands-Free Voice Mode</h3>
      <p>Voice mode keeps the microphone always on to automatically detect when you speak. Your audio is processed securely and not stored.</p>
      <div class="modal-buttons">
        <button class="modal-btn primary" id="continueHandsFreeBtn">Continue</button>
        <button class="modal-btn secondary" id="switchToChatBtn">Switch to Chat</button>
      </div>
    </div>
  </div>
</body>
</html>
